{
  "product": {
    "name": "Sector View",
    "version": "1.0.0",
    "description": "Desktop application for S&P 500 sector analysis and outlier detection",
    "target_platform": "macOS",
    "tech_stack": ["Tauri", "Rust", "React", "TypeScript", "SQLite", "Python"]
  },
  "user_personas": [
    {
      "name": "Day Trader",
      "description": "Active trader looking for quick sector outlier opportunities",
      "goals": ["Find undervalued stocks", "Identify momentum plays", "React to market changes quickly"]
    },
    {
      "name": "Portfolio Manager", 
      "description": "Professional managing diversified portfolios",
      "goals": ["Sector rotation strategies", "Risk management", "Performance attribution"]
    },
    {
      "name": "Job Seeker",
      "description": "Developer showcasing technical skills",
      "goals": ["Demonstrate full-stack abilities", "Show financial domain knowledge", "Create impressive portfolio piece"]
    }
  ],
  "user_stories": {
    "epic_1_basic_ui": {
      "title": "Basic Application Shell",
      "priority": "P0",
      "stories": [
        {
          "id": "US001",
          "title": "As a user, I want to launch the desktop app",
          "description": "Create basic Tauri app that opens a window with React frontend",
          "acceptance_criteria": [
            "App launches without errors",
            "Window is resizable and proper size (1200x800)",
            "Shows 'Sector View' title",
            "App icon appears in dock"
          ],
          "complexity": "Small",
          "estimated_hours": 2,
          "dependencies": [],
          "status": "Not Started",
          "implementation_details": {
            "setup_commands": [
              "cd /Users/collettemilton/code/sector-view",
              "npm create tauri-app@latest .",
              "Choose: React + TypeScript template",
              "Configure app name: 'Sector View'"
            ],
            "key_files": {
              "src-tauri/tauri.conf.json": {
                "description": "Configure window settings and app metadata",
                "key_changes": [
                  "Set productName to 'Sector View'",
                  "Set window title to 'Sector View'", 
                  "Set window dimensions: 1200x800",
                  "Set minWidth: 800, minHeight: 600"
                ]
              },
              "src/App.tsx": {
                "description": "Basic React component showing app title",
                "key_changes": [
                  "Replace default content with 'Sector View' heading",
                  "Add basic CSS styling for clean appearance"
                ]
              }
            },
            "testing_commands": [
              "npm run tauri dev - launch in development mode",
              "npm run tauri build - create production bundle",
              "Verify bundle size < 15MB"
            ],
            "validation_steps": [
              "App launches without console errors",
              "Window opens at 1200x800 dimensions",
              "Window is resizable with proper min dimensions",
              "Title bar displays 'Sector View'",
              "App icon appears in macOS dock",
              "UI shows clean, minimal interface ready for next story"
            ]
          }
        },
        {
          "id": "US002", 
          "title": "As a user, I want to see a basic sector grid layout",
          "description": "Create React components for displaying 11 GICS sectors in a grid",
          "acceptance_criteria": [
            "3x4 grid layout with 11 sector cards (1 empty slot for symmetry)",
            "Each card shows sector name and symbol (e.g., 'Technology (XLK)')",
            "Cards have consistent styling with hover effects",
            "Grid is responsive to window resizing",
            "Placeholder data shows until real data loads"
          ],
          "complexity": "Small",
          "estimated_hours": 3,
          "dependencies": ["US001"],
          "status": "Not Started",
          "implementation_details": {
            "ui_design": {
              "layout": "CSS Grid with 4 columns, auto rows",
              "card_size": "280px width, 180px height (approximate)",
              "spacing": "16px gaps between cards",
              "responsive_breakpoints": [
                "< 1000px: 3 columns",
                "< 800px: 2 columns", 
                "< 500px: 1 column"
              ]
            },
            "component_structure": {
              "src/components/SectorGrid.tsx": {
                "description": "Main container component that fetches and displays all sectors",
                "responsibilities": [
                  "Fetch sectors using useDatabase hook",
                  "Handle loading and error states",
                  "Render grid of SectorCard components"
                ],
                "example_jsx": [
                  "const SectorGrid = () => {",
                  "  const { getSectors } = useDatabase();",
                  "  const [sectors, setSectors] = useState<Sector[]>([]);",
                  "  const [loading, setLoading] = useState(true);",
                  "",
                  "  useEffect(() => {",
                  "    const loadSectors = async () => {",
                  "      try {",
                  "        const data = await getSectors();",
                  "        setSectors(data);",
                  "      } catch (error) {",
                  "        console.error('Failed to load sectors:', error);",
                  "      } finally {",
                  "        setLoading(false);",
                  "      }",
                  "    };",
                  "    loadSectors();",
                  "  }, []);",
                  "",
                  "  if (loading) return <div className=\"loading\">Loading sectors...</div>;",
                  "",
                  "  return (",
                  "    <div className=\"sector-grid\">",
                  "      {sectors.map(sector => (",
                  "        <SectorCard key={sector.id} sector={sector} />",
                  "      ))}",
                  "    </div>",
                  "  );",
                  "};"
                ]
              },
              "src/components/SectorCard.tsx": {
                "description": "Individual sector card component",
                "props": "{ sector: Sector }",
                "example_jsx": [
                  "interface SectorCardProps {",
                  "  sector: Sector;",
                  "}",
                  "",
                  "const SectorCard = ({ sector }: SectorCardProps) => {",
                  "  return (",
                  "    <div className=\"sector-card\">",
                  "      <div className=\"sector-header\">",
                  "        <h3 className=\"sector-name\">{sector.name}</h3>",
                  "        <span className=\"sector-symbol\">({sector.symbol})</span>",
                  "      </div>",
                  "      <div className=\"sector-metrics\">",
                  "        <div className=\"metric\">",
                  "          <span className=\"metric-label\">Change:</span>",
                  "          <span className=\"metric-value placeholder\">--</span>",
                  "        </div>",
                  "        <div className=\"metric\">",
                  "          <span className=\"metric-label\">Outliers:</span>",
                  "          <span className=\"metric-value placeholder\">--</span>",
                  "        </div>",
                  "      </div>",
                  "    </div>",
                  "  );",
                  "};"
                ]
              }
            },
            "css_styling": {
              "src/styles/SectorGrid.css": {
                "description": "Grid layout and responsive behavior",
                "key_styles": [
                  ".sector-grid {",
                  "  display: grid;",
                  "  grid-template-columns: repeat(4, 1fr);",
                  "  gap: 16px;",
                  "  padding: 20px;",
                  "  max-width: 1200px;",
                  "  margin: 0 auto;",
                  "}",
                  "",
                  "@media (max-width: 1000px) {",
                  "  .sector-grid {",
                  "    grid-template-columns: repeat(3, 1fr);",
                  "  }",
                  "}",
                  "",
                  "@media (max-width: 800px) {",
                  "  .sector-grid {",
                  "    grid-template-columns: repeat(2, 1fr);",
                  "  }",
                  "}",
                  "",
                  "@media (max-width: 500px) {",
                  "  .sector-grid {",
                  "    grid-template-columns: 1fr;",
                  "  }",
                  "}"
                ]
              },
              "src/styles/SectorCard.css": {
                "description": "Individual card styling with hover effects",
                "key_styles": [
                  ".sector-card {",
                  "  background: #ffffff;",
                  "  border: 1px solid #e2e8f0;",
                  "  border-radius: 8px;",
                  "  padding: 20px;",
                  "  box-shadow: 0 1px 3px rgba(0,0,0,0.1);",
                  "  transition: all 0.2s ease;",
                  "  cursor: pointer;",
                  "}",
                  "",
                  ".sector-card:hover {",
                  "  transform: translateY(-2px);",
                  "  box-shadow: 0 4px 12px rgba(0,0,0,0.15);",
                  "  border-color: #3b82f6;",
                  "}",
                  "",
                  ".sector-header {",
                  "  margin-bottom: 16px;",
                  "}",
                  "",
                  ".sector-name {",
                  "  font-size: 18px;",
                  "  font-weight: 600;",
                  "  margin: 0 0 4px 0;",
                  "  color: #1f2937;",
                  "}",
                  "",
                  ".sector-symbol {",
                  "  font-size: 14px;",
                  "  color: #6b7280;",
                  "  font-weight: 500;",
                  "}",
                  "",
                  ".sector-metrics {",
                  "  display: flex;",
                  "  flex-direction: column;",
                  "  gap: 8px;",
                  "}",
                  "",
                  ".metric {",
                  "  display: flex;",
                  "  justify-content: space-between;",
                  "  align-items: center;",
                  "}",
                  "",
                  ".metric-label {",
                  "  font-size: 14px;",
                  "  color: #6b7280;",
                  "}",
                  "",
                  ".metric-value {",
                  "  font-size: 16px;",
                  "  font-weight: 600;",
                  "}",
                  "",
                  ".metric-value.placeholder {",
                  "  color: #d1d5db;",
                  "}"
                ]
              }
            },
            "mock_data_approach": {
              "during_development": "Use hardcoded array of 11 sectors for initial testing",
              "example_mock_data": [
                "const mockSectors: Sector[] = [",
                "  { id: 1, name: 'Information Technology', symbol: 'XLK' },",
                "  { id: 2, name: 'Health Care', symbol: 'XLV' },",
                "  // ... rest of sectors",
                "];",
                "",
                "// Replace with real useDatabase call later"
              ],
              "placeholder_content": "Show '--' for metrics that will be populated in US007"
            },
            "integration_points": {
              "us006_connection": "Uses useDatabase hook from US006 to fetch real sector data",
              "us007_preparation": "Cards have placeholder areas for price change and outlier counts",
              "future_interactivity": "Cards are clickable (hover effects) for future drill-down features"
            },
            "accessibility": [
              "Proper heading hierarchy (h3 for sector names)",
              "Sufficient color contrast for text",
              "Keyboard navigation support (focus states)",
              "Screen reader friendly labels"
            ],
            "validation_steps": [
              "Grid displays 11 sector cards in organized layout",
              "Each card shows sector name and symbol correctly",
              "Grid responds to window resizing (test different breakpoints)",
              "Hover effects work smoothly",
              "Loading state shows while data fetches",
              "Error handling works if getSectors() fails",
              "Cards have placeholder content for future metrics"
            ]
          }
        },
        {
          "id": "US003",
          "title": "As a user, I want a refresh button to update data",
          "description": "Add manual refresh functionality with loading states and user feedback",
          "acceptance_criteria": [
            "Main refresh button in top toolbar (global refresh all stocks + discovery)",
            "Mini refresh buttons on individual sector cards (sector-specific refresh)",
            "Both buttons show loading states when pressed (spinner + disabled)",
            "Global refresh: updates all stocks + discovers new ones",
            "Sector refresh: updates only stocks in that specific sector",
            "Success/error feedback shows what was updated with appropriate scope",
            "Prevents multiple simultaneous refreshes (disable all refresh buttons during any refresh)"
          ],
          "complexity": "Small", 
          "estimated_hours": 2,
          "dependencies": ["US002"],
          "status": "Not Started",
          "implementation_details": {
            "ui_design": {
              "global_refresh_button": {
                "location": "Top toolbar/header area, right side",
                "style": "Primary button with refresh icon + 'Refresh' text",
                "loading_state": "Spinner icon replaces refresh icon, button disabled and shows 'Refreshing...'",
                "scope": "Updates all stocks + discovers new ones"
              },
              "sector_refresh_buttons": {
                "location": "Small refresh icon in top-right corner of each sector card",
                "style": "Small circular button with refresh icon only (no text)",
                "loading_state": "Mini spinner replaces refresh icon for that sector only",
                "scope": "Updates only stocks in that specific sector",
                "visual_design": "Subtle, doesn't interfere with sector card layout"
              },
              "feedback": "Toast notification shows scope: 'Updated all stocks' vs 'Updated 12 Technology stocks'"
            },
            "triple_refresh_strategy": {
              "global_refresh": {
                "trigger": "Main refresh button in header",
                "purpose": "Update all stocks + discover new ones", 
                "scope": "All stocks across all sectors",
                "user_feedback": "Updated 55 stocks, found 2 new stocks",
                "use_case": "Full data refresh, daily/weekly maintenance"
              },
              "sector_refresh": {
                "trigger": "Mini refresh button on individual sector cards",
                "purpose": "Update only stocks within a specific sector",
                "scope": "Only stocks where sector_id matches selected sector",
                "user_feedback": "Updated 12 Technology stocks",
                "benefits": [
                  "Faster refresh (fewer API calls)",
                  "Focused analysis - no waiting for unrelated sectors",
                  "Better UX when drilling into specific sector",
                  "Reduced API usage = more frequent refreshes possible"
                ],
                "use_case": "User analyzing specific sector, wants latest data for just those stocks"
              },
              "stock_discovery": {
                "trigger": "Part of global refresh only (not sector-specific)",
                "purpose": "Find new S&P 500 additions, sector changes, newly public companies",
                "why_needed": [
                  "S&P 500 composition changes quarterly",
                  "Companies can switch sectors (e.g., Tesla sector changes)",
                  "New IPOs may enter major indices",
                  "Mergers/acquisitions affect stock universe"
                ],
                "implementation_approach": [
                  "Fetch current S&P 500 component list from reliable source",
                  "Compare against existing stocks table",
                  "Add new stocks with proper sector classification",
                  "Mark removed/delisted stocks (don't delete - keep historical data)"
                ],
                "user_feedback": "Shows 'Found 3 new stocks' or 'No new stocks found'"
              },
              "refresh_flows": {
                "global_flow": [
                  "1. User clicks main refresh button",
                  "2. Update all existing stock data",
                  "3. Check for new stocks in S&P 500",
                  "4. Add newly discovered stocks to database",
                  "5. Update all sector cards with fresh data",
                  "6. Show: 'Updated 55 stocks, found 2 new stocks'"
                ],
                "sector_flow": [
                  "1. User clicks mini refresh on Technology sector card",
                  "2. Update only stocks where sector_id = Technology ID",
                  "3. Update just the Technology sector card",
                  "4. Show: 'Updated 12 Technology stocks'"
                ]
              }
            },
            "user_control_philosophy": {
              "manual_over_automatic": "User decides when to refresh rather than automatic intervals",
              "benefits": [
                "Respects API rate limits (user won't spam refresh)",
                "Saves battery/resources", 
                "User controls when they see new data",
                "No surprise data changes during analysis"
              ],
              "future_enhancement": "US015 will add optional auto-refresh for users who want it"
            },
            "component_structure": {
              "src/components/Header.tsx": {
                "description": "Top toolbar with app title and refresh button",
                "example_jsx": [
                  "const Header = () => {",
                  "  const [refreshing, setRefreshing] = useState(false);",
                  "  const [lastRefresh, setLastRefresh] = useState<Date | null>(null);",
                  "",
                  "  const handleRefresh = async () => {",
                  "    if (refreshing) return; // Prevent double-clicks",
                  "",
                  "    setRefreshing(true);",
                  "    try {",
                  "      // For now: just simulate data refresh",
                  "      await new Promise(resolve => setTimeout(resolve, 1500));",
                  "      setLastRefresh(new Date());",
                  "      showToast('Data refreshed successfully', 'success');",
                  "    } catch (error) {",
                  "      showToast('Failed to refresh data', 'error');",
                  "    } finally {",
                  "      setRefreshing(false);",
                  "    }",
                  "  };",
                  "",
                  "  return (",
                  "    <header className=\"app-header\">",
                  "      <h1 className=\"app-title\">Sector View</h1>",
                  "      <div className=\"header-actions\">",
                  "        {lastRefresh && (",
                  "          <span className=\"last-refresh\">",
                  "            Last updated: {formatTime(lastRefresh)}",
                  "          </span>",
                  "        )}",
                  "        <button",
                  "          className={`refresh-btn ${refreshing ? 'loading' : ''}`}",
                  "          onClick={handleRefresh}",
                  "          disabled={refreshing}",
                  "        >",
                  "          {refreshing ? (",
                  "            <>",
                  "              <SpinnerIcon className=\"spin\" />",
                  "              Refreshing...",
                  "            </>",
                  "          ) : (",
                  "            <>",
                  "              <RefreshIcon />",
                  "              Refresh",
                  "            </>",
                  "          )}",
                  "        </button>",
                  "      </div>",
                  "    </header>",
                  "  );",
                  "};"
                ]
              },
              "src/components/Toast.tsx": {
                "description": "Simple toast notification system for user feedback",
                "purpose": "Show success/error messages after refresh attempts"
              },
              "src/components/SectorCard.tsx": {
                "description": "Enhanced sector card with individual refresh capability",
                "new_features": [
                  "Mini refresh button in top-right corner",
                  "Sector-specific loading state",
                  "Only refreshes stocks for this sector"
                ],
                "example_additions": [
                  "const [sectorRefreshing, setSectorRefreshing] = useState(false);",
                  "",
                  "const handleSectorRefresh = async () => {",
                  "  setSectorRefreshing(true);",
                  "  try {",
                  "    // Call API to refresh only this sector's stocks",
                  "    await refreshSectorStocks(sector.id);", 
                  "    showToast(`Updated ${stockCount} ${sector.name} stocks`, 'success');",
                  "  } catch (error) {",
                  "    showToast(`Failed to refresh ${sector.name}`, 'error');",
                  "  } finally {",
                  "    setSectorRefreshing(false);",
                  "  }",
                  "};",
                  "",
                  "// Add mini refresh button to sector card JSX",
                  "<button className=\"sector-refresh-mini\" onClick={handleSectorRefresh}>",
                  "  {sectorRefreshing ? <MiniSpinner /> : <RefreshIcon />}",
                  "</button>"
                ]
              }
            },
            "mock_data_strategy": {
              "during_us003": "Simulate refresh by changing placeholder values or timestamps",
              "example_mock_refresh": [
                "// Simulate data change by updating timestamp or random values",
                "const mockRefresh = () => {",
                "  const mockChanges = ['+1.2%', '-0.8%', '+2.1%', '--'];",
                "  const randomChange = mockChanges[Math.floor(Math.random() * mockChanges.length)];",
                "  // Update sector cards with new mock values",
                "};"
              ],
              "visual_feedback": "Show different placeholder values, updated timestamps, or subtle animation"
            },
            "integration_with_future_stories": {
              "us005_expansion": "Stock discovery adds new entries to seed data automatically",
              "us007_connection": "Refresh button will call market data refresh functions for both existing and new stocks",
              "refresh_context": "Pass refresh trigger down to SectorGrid component to re-render with new stocks",
              "data_invalidation": "Clear cached data and fetch fresh from API for all stocks (existing + newly discovered)"
            },
            "css_styling": {
              "src/styles/Header.css": {
                "key_styles": [
                  ".app-header {",
                  "  display: flex;",
                  "  justify-content: space-between;",
                  "  align-items: center;",
                  "  padding: 16px 24px;",
                  "  background: #ffffff;",
                  "  border-bottom: 1px solid #e2e8f0;",
                  "  box-shadow: 0 1px 3px rgba(0,0,0,0.1);",
                  "}",
                  "",
                  ".app-title {",
                  "  font-size: 24px;",
                  "  font-weight: 700;",
                  "  color: #1f2937;",
                  "  margin: 0;",
                  "}",
                  "",
                  ".header-actions {",
                  "  display: flex;",
                  "  align-items: center;",
                  "  gap: 16px;",
                  "}",
                  "",
                  ".last-refresh {",
                  "  font-size: 14px;",
                  "  color: #6b7280;",
                  "}",
                  "",
                  ".refresh-btn {",
                  "  display: flex;",
                  "  align-items: center;",
                  "  gap: 8px;",
                  "  background: #3b82f6;",
                  "  color: white;",
                  "  border: none;",
                  "  border-radius: 6px;",
                  "  padding: 10px 16px;",
                  "  font-size: 14px;",
                  "  font-weight: 500;",
                  "  cursor: pointer;",
                  "  transition: all 0.2s ease;",
                  "}",
                  "",
                  ".refresh-btn:hover:not(:disabled) {",
                  "  background: #2563eb;",
                  "  transform: translateY(-1px);",
                  "}",
                  "",
                  ".refresh-btn:disabled {",
                  "  opacity: 0.7;",
                  "  cursor: not-allowed;",
                  "  transform: none;",
                  "}",
                  "",
                  ".spin {",
                  "  animation: spin 1s linear infinite;",
                  "}",
                  "",
                  "@keyframes spin {",
                  "  from { transform: rotate(0deg); }",
                  "  to { transform: rotate(360deg); }",
                  "}"
                ]
              }
            },
            "user_experience_details": {
              "double_click_prevention": "Disable button while refreshing to prevent multiple API calls",
              "visual_feedback": "Spinner animation and text change during refresh",
              "timestamp_display": "Show 'Last updated: 2:34 PM' so users know data freshness",
              "error_handling": "Clear error messages, don't crash on failed refresh"
            },
            "accessibility": [
              "Button has proper ARIA labels",
              "Loading state announced to screen readers", 
              "Keyboard navigation support",
              "High contrast button colors"
            ],
            "validation_steps": [
              "Global refresh button appears in top toolbar with proper styling",
              "Mini refresh buttons appear on each sector card (top-right corner)",
              "Global refresh shows loading state and updates all sector cards",
              "Sector refresh shows loading state only on that specific card",
              "Global refresh success: 'Updated X stocks, found Y new stocks'",
              "Sector refresh success: 'Updated X [Sector Name] stocks'",
              "Error messages show appropriate scope (global vs sector-specific)",
              "Double-clicking doesn't trigger multiple refreshes (global or sector)",
              "During any refresh, all refresh buttons are disabled to prevent conflicts",
              "Last refresh timestamp updates correctly (global timestamp)",
              "Sector-specific refresh only changes data for that one sector",
              "Global refresh changes data across all sectors + may add new stocks",
              "All buttons return to normal state after refresh completes"
            ]
          }
        }
      ]
    },
    "epic_2_data_layer": {
      "title": "Data Foundation",
      "priority": "P0",
      "stories": [
        {
          "id": "US004",
          "title": "As a developer, I want SQLite database setup",
          "description": "Create minimal database schema and connection handling",
          "acceptance_criteria": [
            "SQLite database file created in app data directory",
            "Basic sectors and stocks tables created",
            "Database connection established in Rust",
            "Migration system for future schema changes",
            "Error handling for database failures"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": [],
          "status": "Not Started",
          "implementation_details": {
            "minimal_schema": {
              "philosophy": "Start with just sectors and stocks tables. Add market data tables later when we implement US007 (market data integration).",
              "tables": {
                "sectors": [
                  "id INTEGER PRIMARY KEY",
                  "name TEXT NOT NULL (e.g., 'Technology')",
                  "symbol TEXT NOT NULL (e.g., 'XLK' - sector ETF symbol)"
                ],
                "stocks": [
                  "id INTEGER PRIMARY KEY", 
                  "symbol TEXT NOT NULL (e.g., 'AAPL')",
                  "name TEXT NOT NULL (e.g., 'Apple Inc.')",
                  "sector_id INTEGER NULL REFERENCES sectors(id) -- Nullable for unclassified stocks"
                ]
              }
            },
            "rust_dependencies": [
              "sqlx = { version = '0.7', features = ['sqlite', 'runtime-tokio-rustls'] }",
              "tokio = { version = '1.0', features = ['full'] }"
            ],
            "key_files": {
              "src-tauri/src/database.rs": {
                "description": "Database connection and basic operations",
                "functions": [
                  "init_database() -> Result<SqlitePool>",
                  "create_tables() -> Result<()>", 
                  "get_connection() -> &SqlitePool"
                ]
              },
              "src-tauri/migrations/001_initial.sql": {
                "description": "Initial schema creation",
                "content": "CREATE TABLE sectors...; CREATE TABLE stocks...;"
              }
            },
            "validation_steps": [
              "Database file created at correct app data location",
              "Tables created successfully with correct schema",
              "Can insert/select from both tables",
              "Can insert stocks with NULL sector_id (unclassified stocks)",
              "Connection pool handles multiple queries",
              "Graceful error handling for DB failures"
            ],
            "handling_null_sectors": {
              "ui_display": "Show unclassified stocks in separate 'Unclassified' section",
              "outlier_analysis": "Exclude NULL sector stocks from sector-based outlier detection",
              "data_loading": "Allow stock imports to succeed even without sector assignment"
            },
            "future_evolution": [
              "US007: Add market_data table for prices/volume",
              "US008: Add outlier_alerts table for detection results", 
              "US012: Add historical_data table for time series"
            ]
          }
        },
        {
          "id": "US005",
          "title": "As a developer, I want to populate initial sector data",
          "description": "Seed database with 11 GICS sectors and major S&P 500 stocks",
          "acceptance_criteria": [
            "All 11 GICS sectors inserted with ETF symbols",
            "Representative S&P 500 stocks added per sector (~50-100 total for MVP)",
            "Proper foreign key relationships established",
            "Some stocks with NULL sector_id for testing edge cases"
          ],
          "complexity": "Medium",
          "estimated_hours": 3,
          "dependencies": ["US004"],
          "status": "Not Started",
          "implementation_details": {
            "sector_seed_data": [
              { "symbol": "XLK", "name": "Information Technology" },
              { "symbol": "XLV", "name": "Health Care" },
              { "symbol": "XLF", "name": "Financials" },
              { "symbol": "XLY", "name": "Consumer Discretionary" },
              { "symbol": "XLC", "name": "Communication Services" },
              { "symbol": "XLI", "name": "Industrials" },
              { "symbol": "XLP", "name": "Consumer Staples" },
              { "symbol": "XLE", "name": "Energy" },
              { "symbol": "XLU", "name": "Utilities" },
              { "symbol": "XLRE", "name": "Real Estate" },
              { "symbol": "XLB", "name": "Materials" }
            ],
            "sample_stocks_per_sector": {
              "XLK": ["AAPL", "MSFT", "GOOGL", "NVDA", "META"],
              "XLV": ["JNJ", "PFE", "UNH", "ABBV", "TMO"],
              "XLF": ["JPM", "BAC", "WFC", "GS", "MS"],
              "XLY": ["AMZN", "TSLA", "HD", "MCD", "NKE"],
              "XLC": ["GOOGL", "META", "VZ", "T", "DIS"],
              "XLI": ["BA", "CAT", "UPS", "GE", "RTX"],
              "XLP": ["PG", "KO", "PEP", "WMT", "COST"],
              "XLE": ["XOM", "CVX", "COP", "EOG", "SLB"],
              "XLU": ["NEE", "SO", "DUK", "AEP", "EXC"],
              "XLRE": ["AMT", "PLD", "CCI", "EQIX", "SPG"],
              "XLB": ["LIN", "APD", "SHW", "FCX", "DOW"]
            },
            "seed_approach": "Start with ~5 major stocks per sector for MVP. Can expand to full S&P 500 later.",
            "key_files": {
              "src-tauri/src/seed_data.rs": {
                "description": "Hardcoded sector and stock data for initial population",
                "functions": [
                  "seed_sectors() -> Result<()>",
                  "seed_sample_stocks() -> Result<()>",
                  "seed_unclassified_examples() -> Result<()>"
                ]
              }
            },
            "validation_steps": [
              "All 11 sectors inserted with correct ETF symbols",
              "Sample stocks inserted with proper sector assignments",
              "At least 1-2 stocks with NULL sector_id for edge case testing",
              "Foreign key relationships working correctly",
              "No duplicate symbols in either table"
            ]
          }
        },
        {
          "id": "US006",
          "title": "As a developer, I want Tauri commands for data access",
          "description": "Create Rust commands that React can call for database operations",
          "acceptance_criteria": [
            "get_sectors() command returns all sectors",
            "get_stocks_by_sector(id) returns stocks for a sector", 
            "Commands handle errors gracefully",
            "TypeScript interfaces defined for return types",
            "React components can successfully call Rust functions"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US005"],
          "status": "Not Started",
          "implementation_details": {
            "tauri_concepts": {
              "what_are_commands": "Tauri commands are Rust functions that React can call like API endpoints. They're the bridge between your frontend and backend.",
              "how_it_works": [
                "1. Write Rust function with #[tauri::command] annotation",
                "2. Register command in main.rs",
                "3. Call from React using invoke() function",
                "4. Data flows: React -> Tauri -> Rust -> Database -> Rust -> Tauri -> React"
              ],
              "beginner_friendly": "Don't worry about complex Rust concepts yet - focus on the patterns and copy-paste approach"
            },
            "step_by_step": {
              "1_create_types": {
                "file": "src-tauri/src/types.rs",
                "purpose": "Define data structures shared between Rust and React",
                "code": "use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Sector {\n    pub id: i32,\n    pub name: String,\n    pub symbol: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Stock {\n    pub id: i32,\n    pub symbol: String,\n    pub name: String,\n    pub sector_id: Option<i32>,\n}"
              },
              "2_create_commands": {
                "file": "src-tauri/src/commands.rs", 
                "purpose": "Write the actual functions React can call",
                "code": "use crate::{database::get_connection, types::{Sector, Stock}};\n\n#[tauri::command]\npub async fn get_sectors() -> Result<Vec<Sector>, String> {\n    let pool = get_connection().map_err(|e| e.to_string())?;\n    \n    let rows = sqlx::query!(\"SELECT id, name, symbol FROM sectors\")\n        .fetch_all(&pool)\n        .await\n        .map_err(|e| format!(\"Database error: {}\", e))?;\n    \n    let sectors = rows.into_iter().map(|row| Sector {\n        id: row.id,\n        name: row.name,\n        symbol: row.symbol,\n    }).collect();\n    \n    Ok(sectors)\n}\n\n#[tauri::command]\npub async fn get_stocks_by_sector(sector_id: i32) -> Result<Vec<Stock>, String> {\n    let pool = get_connection().map_err(|e| e.to_string())?;\n    \n    let rows = sqlx::query!(\"SELECT id, symbol, name, sector_id FROM stocks WHERE sector_id = ?\", sector_id)\n        .fetch_all(&pool)\n        .await\n        .map_err(|e| format!(\"Database error: {}\", e))?;\n    \n    let stocks = rows.into_iter().map(|row| Stock {\n        id: row.id,\n        symbol: row.symbol,\n        name: row.name,\n        sector_id: row.sector_id,\n    }).collect();\n    \n    Ok(stocks)\n}"
              },
              "3_register_commands": {
                "file": "src-tauri/src/main.rs",
                "purpose": "Tell Tauri about your commands",
                "changes": "Add: mod commands;\nmod types;\n\nIn .invoke_handler(): commands::get_sectors, commands::get_stocks_by_sector"
              },
              "4_react_types": {
                "file": "src/types/database.ts",
                "purpose": "TypeScript interfaces matching Rust structs",
                "code": "export interface Sector {\n  id: number;\n  name: string;\n  symbol: string;\n}\n\nexport interface Stock {\n  id: number;\n  symbol: string;\n  name: string;\n  sector_id: number | null;\n}"
              },
              "5_react_hook": {
                "file": "src/hooks/useDatabase.ts", 
                "purpose": "Easy way to call Rust from React components",
                "code": "import { invoke } from '@tauri-apps/api/tauri';\nimport { Sector, Stock } from '../types/database';\n\nexport const useDatabase = () => {\n  const getSectors = async (): Promise<Sector[]> => {\n    try {\n      return await invoke<Sector[]>('get_sectors');\n    } catch (error) {\n      console.error('Failed to get sectors:', error);\n      throw error;\n    }\n  };\n\n  const getStocksBySector = async (sectorId: number): Promise<Stock[]> => {\n    try {\n      return await invoke<Stock[]>('get_stocks_by_sector', { sectorId });\n    } catch (error) {\n      console.error('Failed to get stocks:', error);\n      throw error;\n    }\n  };\n\n  return { getSectors, getStocksBySector };\n};"
              }
            },
            "rust_for_beginners": {
              "key_concepts": {
                "Result<T, E>": "Rust's way of handling success (T) or error (E)",
                "#[tauri::command]": "Annotation that makes Rust function callable from React",
                "async/await": "Non-blocking operations for database calls",
                "map_err()": "Convert different error types to String for Tauri",
                "Option<T>": "Rust's way of saying 'this might be null'"
              },
              "copy_paste_approach": "Don't worry about understanding every Rust detail - focus on the patterns and modify as needed"
            },
            "testing_strategy": [
              "1. Start with get_sectors() - no parameters, easier to test",
              "2. Test in browser console: await window.__TAURI__.invoke('get_sectors')",
              "3. Add get_stocks_by_sector() once first command works", 
              "4. Create React components that use the hooks",
              "5. Add error handling and loading states"
            ],
            "validation_steps": [
              "Can call get_sectors() from React browser console",
              "Returns array of 11 sectors with correct structure",
              "Can call get_stocks_by_sector(1) and get stocks for sector 1",
              "TypeScript types prevent errors (no red squiggles)", 
              "Error handling works (try invalid sector ID)",
              "React components can use the database hooks successfully"
            ]
          }
        }
      ]
    },
    "epic_3_market_data": {
      "title": "Real Market Data Integration", 
      "priority": "P1",
      "stories": [
        {
          "id": "US007",
          "title": "As a user, I want to see real sector performance data",
          "description": "Connect to Yahoo Finance API and display actual market data",
          "acceptance_criteria": [
            "Yahoo Finance API integration working for both price and fundamental data",
            "Sector cards show multiple metrics (price change %, avg P/E, market cap)",
            "Market data table captures comprehensive financial metrics",
            "Data updates when refresh is pressed", 
            "Handles API errors gracefully (shows cached data)",
            "Respects API rate limits (no more than 2000 requests/hour)",
            "Missing fundamental data handled without crashes"
          ],
          "complexity": "Large",
          "estimated_hours": 8,
          "dependencies": ["US006"],
          "status": "Not Started",
          "implementation_details": {
            "api_strategy": {
              "primary": "Yahoo Finance via Rust reqwest HTTP client",
              "endpoints": {
                "quotes": "https://query1.finance.yahoo.com/v8/finance/chart/{symbol}",
                "fundamentals": "https://query2.finance.yahoo.com/v10/finance/quoteSummary/{symbol}?modules=defaultKeyStatistics,summaryDetail,price"
              },
              "rate_limit": "2000 requests/hour (Yahoo's free tier)",
              "data_richness": "Fetch comprehensive metrics: price, volume, P/E, market cap, beta, 52-week range, etc.",
              "backup_plan": "If blocked, fall back to cached data or yfinance Python service"
            },
            "database_evolution": {
              "new_table": "market_data",
              "schema": [
                "id INTEGER PRIMARY KEY",
                "stock_id INTEGER NOT NULL REFERENCES stocks(id)",
                "timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP",
                "-- Price Data --",
                "price REAL NOT NULL",
                "price_change REAL NOT NULL -- Dollar change from previous close",
                "price_change_percent REAL NOT NULL -- Percentage change",
                "-- Volume & Liquidity --", 
                "volume INTEGER",
                "avg_volume_10d INTEGER -- 10-day average volume",
                "-- Market & Valuation --",
                "market_cap INTEGER",
                "pe_ratio REAL -- Price-to-Earnings ratio",
                "pb_ratio REAL -- Price-to-Book ratio",
                "-- Profitability --",
                "eps REAL -- Earnings Per Share",
                "dividend_yield REAL -- Annual dividend yield %",
                "-- Volatility --",
                "beta REAL -- Stock beta (volatility vs market)",
                "-- 52-Week Range --",
                "week52_high REAL",
                "week52_low REAL"
              ],
              "indexes": [
                "CREATE INDEX idx_market_data_stock_timestamp ON market_data(stock_id, timestamp)",
                "CREATE INDEX idx_market_data_timestamp ON market_data(timestamp)"
              ]
            },
            "data_flow": [
              "1. Fetch comprehensive stock data for all seeded stocks (~55 stocks)",
              "2. Parse both price data (chart API) and fundamentals (quoteSummary API)",
              "3. Insert/update market_data table with rich financial metrics",
              "4. Calculate sector averages across multiple dimensions:",
              "   - Price performance (%, volume-weighted)",
              "   - Valuation metrics (avg P/E, P/B ratios per sector)", 
              "   - Volatility (avg beta, price volatility)",
              "   - Market cap distribution",
              "5. Cache multi-dimensional sector data for UI and outlier detection",
              "6. Update React UI with comprehensive sector analytics"
            ],
            "caching_strategy": {
              "in_memory": "Store latest sector averages in Rust HashMap",
              "database": "Keep last 24h of market_data for offline fallback",
              "ttl": "Cache valid for 15 minutes during market hours",
              "offline_mode": "Show cached data with timestamp when API fails"
            },
            "rust_dependencies": [
              "reqwest = { version = '0.11', features = ['json'] }",
              "serde = { version = '1.0', features = ['derive'] }",
              "serde_json = '1.0'",
              "chrono = { version = '0.4', features = ['serde'] }"
            ],
            "key_files": {
              "src-tauri/src/market_data.rs": {
                "description": "Yahoo Finance API client and data fetching",
                "functions": [
                  "fetch_stock_quote(symbol: &str) -> Result<StockQuote>",
                  "fetch_all_stocks() -> Result<Vec<StockQuote>>",
                  "calculate_sector_averages(quotes: Vec<StockQuote>) -> HashMap<i32, SectorAverage>"
                ]
              },
              "src-tauri/src/cache.rs": {
                "description": "In-memory caching with TTL",
                "functions": [
                  "get_cached_sectors() -> Option<Vec<SectorSummary>>",
                  "cache_sector_data(data: Vec<SectorSummary>)",
                  "is_cache_expired() -> bool"
                ]
              },
              "src-tauri/migrations/002_market_data.sql": {
                "description": "Add market_data table and indexes",
                "content": "CREATE TABLE market_data (...); CREATE INDEX ..."
              }
            },
            "tauri_commands": [
              "#[tauri::command] async fn refresh_market_data() -> Result<Vec<SectorSummary>, String>",
              "#[tauri::command] async fn get_sector_performance() -> Result<Vec<SectorSummary>, String>"
            ],
            "error_handling": {
              "api_failure": "Return cached data with warning message",
              "rate_limit_hit": "Show 'too many requests' error, use cache",
              "network_timeout": "Fall back to last known data",
              "invalid_response": "Log error, skip problematic stocks"
            },
            "validation_steps": [
              "Can fetch comprehensive data for all seeded stocks (AAPL, MSFT, etc.)",
              "Market data table populated with prices, P/E ratios, market caps, etc.",
              "Sector cards display multiple metrics (price change, avg P/E, etc.)",
              "All fundamental data fields have reasonable values (P/E > 0, market cap > 0)",
              "Cache works - second refresh is faster than first",
              "Graceful degradation when API is unavailable",
              "No rate limit violations during normal usage",
              "Missing data handled gracefully (some stocks may lack P/E, etc.)"
            ]
          }
        },
        {
          "id": "US008",
          "title": "As a user, I want to see multi-dimensional stock outliers in each sector",
          "description": "Implement sophisticated outlier detection across multiple financial metrics with composite scoring",
          "acceptance_criteria": [
            "Calculate sector standard deviations for P/E ratios, P/B ratios, and price changes",
            "Identify stocks >1.5σ from sector average on any metric", 
            "Generate composite outlier score combining multiple metrics",
            "Display outlier count and severity on sector cards",
            "Color code: green for undervalued outliers, red for overvalued outliers",
            "Handle missing data gracefully (not all stocks have P/E ratios)"
          ],
          "complexity": "Large",
          "estimated_hours": 8,
          "dependencies": ["US007"],
          "status": "Not Started",
          "implementation_details": {
            "statistical_methodology": {
              "z_score_calculation": {
                "formula": "z = (value - mean) / standard_deviation",
                "interpretation": [
                  "z > +1.5: Stock significantly above sector average",
                  "z < -1.5: Stock significantly below sector average", 
                  "z between -1.5 and +1.5: Within normal range"
                ],
                "threshold_configurable": "Default 1.5σ, but user can adjust in settings"
              },
              "metrics_analyzed": {
                "price_performance": {
                  "metric": "price_change_percent",
                  "interpretation": "High +z = outperforming sector, Low -z = underperforming sector"
                },
                "valuation_pe": {
                  "metric": "pe_ratio", 
                  "interpretation": "High +z = expensive vs sector, Low -z = cheap vs sector",
                  "null_handling": "Skip stocks with NULL P/E (unprofitable companies)"
                },
                "valuation_pb": {
                  "metric": "pb_ratio",
                  "interpretation": "High +z = trading above book value vs sector, Low -z = trading below book value"
                },
                "trading_activity": {
                  "metric": "volume / avg_volume_10d",
                  "interpretation": "High +z = unusual trading volume vs typical"
                },
                "volatility": {
                  "metric": "beta",
                  "interpretation": "High +z = more volatile than sector average"
                }
              }
            },
            "composite_scoring": {
              "weighted_approach": {
                "description": "Combine multiple Z-scores into single outlier strength score",
                "formula": "composite_score = sqrt(z_pe² + z_pb² + z_price² + z_volume²) / num_valid_metrics",
                "weights": {
                  "pe_ratio": 0.3,
                  "pb_ratio": 0.2, 
                  "price_change": 0.3,
                  "volume_ratio": 0.2
                },
                "interpretation": [
                  "Score 0-1: Normal stock, within sector norms",
                  "Score 1-2: Moderate outlier, worth noting",
                  "Score 2-3: Strong outlier, significant deviation", 
                  "Score 3+: Extreme outlier, investigate immediately"
                ]
              },
              "direction_classification": {
                "undervalued_outlier": "Low P/E + Low P/B + (any price performance)",
                "overvalued_outlier": "High P/E + High P/B + (any price performance)",
                "momentum_outlier": "Strong price performance + high volume",
                "value_trap": "Low P/E + Poor price performance",
                "growth_premium": "High P/E + Strong price performance"
              }
            },
            "rust_implementation": {
              "src-tauri/src/outlier_detection.rs": {
                "description": "Statistical analysis engine in Rust for performance",
                "key_functions": [
                  "calculate_sector_statistics(sector_id: i32) -> SectorStats",
                  "calculate_z_scores(stock: &Stock, sector_stats: &SectorStats) -> ZScores", 
                  "calculate_composite_score(z_scores: &ZScores) -> f64",
                  "classify_outlier_type(z_scores: &ZScores) -> OutlierType",
                  "find_sector_outliers(sector_id: i32, threshold: f64) -> Vec<OutlierStock>"
                ],
                "example_struct": [
                  "#[derive(Debug, Serialize, Deserialize)]",
                  "pub struct SectorStats {",
                  "    pub sector_id: i32,",
                  "    pub stock_count: u32,",
                  "    pub pe_mean: Option<f64>,",
                  "    pub pe_std_dev: Option<f64>,",
                  "    pub pb_mean: Option<f64>, ",
                  "    pub pb_std_dev: Option<f64>,",
                  "    pub price_change_mean: f64,",
                  "    pub price_change_std_dev: f64,",
                  "    pub volume_ratio_mean: f64,",
                  "    pub volume_ratio_std_dev: f64,",
                  "}",
                  "",
                  "#[derive(Debug, Serialize, Deserialize)]",
                  "pub struct ZScores {",
                  "    pub pe_z: Option<f64>,",
                  "    pub pb_z: Option<f64>,", 
                  "    pub price_z: f64,",
                  "    pub volume_z: f64,",
                  "}",
                  "",
                  "#[derive(Debug, Serialize, Deserialize)]",
                  "pub struct OutlierStock {",
                  "    pub stock_id: i32,",
                  "    pub symbol: String,",
                  "    pub name: String,",
                  "    pub z_scores: ZScores,",
                  "    pub composite_score: f64,",
                  "    pub outlier_type: OutlierType,",
                  "    pub significance_level: SignificanceLevel, // Moderate, Strong, Extreme",
                  "}"
                ]
              }
            },
            "algorithm_implementation": {
              "step_by_step_process": [
                "1. For each sector, gather all stocks with valid market data",
                "2. Calculate sector averages and standard deviations for each metric",
                "3. For each stock, calculate Z-scores vs its sector", 
                "4. Compute composite outlier score from individual Z-scores",
                "5. Classify outlier type (undervalued, overvalued, momentum, etc.)",
                "6. Filter stocks above threshold (default 1.5σ composite score)",
                "7. Sort by composite score (strongest outliers first)",
                "8. Return ranked list of outlier stocks per sector"
              ],
              "null_data_handling": [
                "P/E ratio: Skip unprofitable companies (NULL P/E)",
                "P/B ratio: Use median substitution if < 20% missing",
                "Volume: Always available from market data",
                "Composite score: Only use available metrics, adjust denominator"
              ]
            },
            "performance_optimizations": {
              "caching_strategy": "Cache sector statistics (recalculate only on data refresh)",
              "batch_processing": "Calculate all sectors in single database query",
              "indexing": "Ensure market_data table has sector_id index",
              "concurrent_processing": "Use Rust async/await for parallel sector analysis"
            },
            "historical_database_schema": {
              "outlier_detections": {
                "description": "Store historical outlier detection results by date for trend analysis",
                "table_schema": [
                  "CREATE TABLE outlier_detections (",
                  "  id INTEGER PRIMARY KEY,",
                  "  stock_id INTEGER NOT NULL REFERENCES stocks(id),",
                  "  sector_id INTEGER NOT NULL REFERENCES sectors(id),",
                  "  detection_date DATE NOT NULL,",
                  "  detection_timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,",
                  "  -- Z-Scores --",
                  "  pe_z_score REAL,",
                  "  pb_z_score REAL,",
                  "  price_z_score REAL NOT NULL,",
                  "  volume_z_score REAL NOT NULL,",
                  "  -- Composite Analysis --",
                  "  composite_score REAL NOT NULL,",
                  "  outlier_type TEXT NOT NULL, -- 'undervalued', 'overvalued', 'momentum', etc.",
                  "  significance_level TEXT NOT NULL, -- 'moderate', 'strong', 'extreme'",
                  "  threshold_used REAL NOT NULL, -- Which sigma threshold was used",
                  "  INDEX idx_outlier_stock_date (stock_id, detection_date),",
                  "  INDEX idx_outlier_sector_date (sector_id, detection_date),",
                  "  INDEX idx_outlier_date (detection_date)",
                  ");"
                ],
                "data_retention_strategy": [
                  "Store daily outlier detection results",
                  "Keep detailed results for last 90 days",
                  "Aggregate to weekly summaries for 90d-1year",
                  "Monthly summaries for historical data >1 year"
                ]
              },
              "sector_statistics_cache": {
                "description": "Cache sector stats by date to avoid recalculation",
                "table_schema": [
                  "CREATE TABLE sector_stats_daily (",
                  "  id INTEGER PRIMARY KEY,",
                  "  sector_id INTEGER NOT NULL REFERENCES sectors(id),",
                  "  stats_date DATE NOT NULL,",
                  "  stock_count INTEGER NOT NULL,",
                  "  pe_mean REAL,",
                  "  pe_std_dev REAL,", 
                  "  pb_mean REAL,",
                  "  pb_std_dev REAL,",
                  "  price_change_mean REAL NOT NULL,",
                  "  price_change_std_dev REAL NOT NULL,",
                  "  volume_ratio_mean REAL NOT NULL,",
                  "  volume_ratio_std_dev REAL NOT NULL,",
                  "  UNIQUE(sector_id, stats_date)",
                  ");"
                ]
              }
            },
            "integration_with_ui": {
              "sector_card_updates": [
                "Show current outlier count: '8 outliers found'",
                "Show strongest outlier: 'AAPL: 2.8σ composite'",
                "Color coding based on predominant outlier type",
                "Trend indicator: '↗ +2 new outliers vs yesterday'"
              ],
              "tauri_commands": [
                "#[tauri::command]",
                "pub async fn detect_outliers(threshold: f64) -> Result<Vec<SectorOutliers>, String>",
                "",
                "#[tauri::command]", 
                "pub async fn get_sector_outliers(sector_id: i32) -> Result<Vec<OutlierStock>, String>",
                "",
                "#[tauri::command]",
                "pub async fn get_outlier_history(stock_id: i32, days: i32) -> Result<Vec<OutlierDetection>, String>"
              ]
            },
            "validation_and_testing": [
              "Create test cases with known outliers (e.g., stock with P/E 3x sector average)",
              "Verify Z-score calculations match manual calculations", 
              "Test edge cases: all stocks similar (low std dev), missing data",
              "Performance test: 500 stocks across 11 sectors should complete < 1 second",
              "Validate composite scores make intuitive sense"
            ]
          }
        },
        {
          "id": "US018",
          "title": "As a developer, I want comprehensive unit tests for outlier detection mathematics",
          "description": "Ensure statistical calculations are mathematically accurate and reliable through extensive testing",
          "acceptance_criteria": [
            "Z-score calculations produce correct results for known inputs",
            "Composite score (weighted RMS) math is verified against manual calculations",
            "Outlier classification logic correctly maps Z-scores to OutlierType",
            "Significance level thresholds (Moderate/Strong/Extreme) work as specified",
            "Edge cases handled properly (zero std dev, missing data, extreme values)",
            "Performance tests ensure calculations complete within acceptable time limits",
            "Test coverage > 90% for outlier_detection.rs module"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US008"],
          "status": "Not Started",
          "implementation_details": {
            "testing_framework": {
              "rust_testing": "Built-in Rust testing with #[cfg(test)] modules",
              "additional_crates": [
                "approx = \"0.5\" # For floating-point comparisons",
                "proptest = \"1.0\" # Property-based testing for edge cases"
              ],
              "test_organization": "Tests in src/outlier_detection.rs with #[cfg(test)] mod tests"
            },
            "z_score_testing": {
              "basic_correctness": {
                "test_cases": [
                  "Known dataset: mean=10, std_dev=2, value=14 → z=2.0",
                  "Known dataset: mean=50, std_dev=5, value=40 → z=-2.0", 
                  "Zero deviation: all values same → z=0.0",
                  "Negative values: mean=-5, std_dev=3, value=-8 → z=-1.0"
                ],
                "implementation": [
                  "#[test]",
                  "fn test_z_score_calculation() {",
                  "    let mean = 10.0;",
                  "    let std_dev = 2.0;",
                  "    let value = 14.0;",
                  "    let expected_z = 2.0;",
                  "    ",
                  "    let actual_z = calculate_z_score(value, mean, std_dev);",
                  "    ",
                  "    assert!((actual_z - expected_z).abs() < 0.001);",
                  "}"
                ]
              },
              "edge_cases": {
                "zero_std_dev": "When all sector values are identical, z-score should be 0.0",
                "extreme_values": "Very large/small numbers should not cause overflow",
                "missing_data": "Handle None values gracefully in calculations"
              }
            },
            "composite_score_testing": {
              "weighted_rms_formula": "composite = sqrt((w1*z1² + w2*z2² + ... + wn*zn²) / sum_of_weights)",
              "test_scenarios": [
                {
                  "description": "Equal weights, simple values",
                  "input": "z_scores: [1.0, 2.0, -1.0], weights: [1.0, 1.0, 1.0]",
                  "expected": "sqrt((1² + 4 + 1) / 3) = sqrt(2) ≈ 1.414"
                },
                {
                  "description": "Weighted scenario matching US008",
                  "input": "pe_z: -2.0 (weight 0.3), pb_z: -1.5 (weight 0.2), price_z: 0.5 (weight 0.3), volume_z: 3.0 (weight 0.2)",
                  "calculation": "sqrt((0.3*4 + 0.2*2.25 + 0.3*0.25 + 0.2*9) / 1.0)",
                  "expected": "≈ 2.16"
                },
                {
                  "description": "Missing data scenario",
                  "input": "pe_z: None, pb_z: -1.0, price_z: 2.0, volume_z: 1.0",
                  "handling": "Only use available metrics, adjust denominator",
                  "expected": "sqrt((0.2*1 + 0.3*4 + 0.2*1) / 0.7) ≈ 1.96"
                }
              ],
              "precision_testing": "Verify calculations match manual computation to 0.001 precision"
            },
            "outlier_classification_testing": {
              "classification_rules": {
                "undervalued": "Low P/E Z-score (-1.5+) AND Low P/B Z-score (-1.5+)",
                "overvalued": "High P/E Z-score (1.5+) AND High P/B Z-score (1.5+)",
                "momentum": "High price Z-score (1.5+) AND High volume Z-score (1.5+)",
                "value_trap": "Low P/E Z-score (-1.5+) AND Low price Z-score (-1.5+)",
                "mixed": "Doesn't fit clear patterns"
              },
              "test_matrix": [
                "[-2.0, -1.8, 0.2, 0.5] → Undervalued (low P/E, low P/B)",
                "[2.5, 2.0, -0.5, 0.3] → Overvalued (high P/E, high P/B)", 
                "[-0.5, 0.2, 2.2, 3.0] → Momentum (high price, high volume)",
                "[-2.0, 0.5, -1.8, 1.0] → Value Trap (low P/E, poor price)",
                "[0.5, -0.3, 1.2, -0.8] → Mixed (no clear pattern)"
              ]
            },
            "significance_threshold_testing": {
              "threshold_definitions": {
                "moderate": "1.5σ ≤ composite_score < 2.0σ",
                "strong": "2.0σ ≤ composite_score < 3.0σ", 
                "extreme": "composite_score ≥ 3.0σ"
              },
              "boundary_testing": [
                "composite_score = 1.49 → Below threshold (not outlier)",
                "composite_score = 1.50 → Moderate outlier",
                "composite_score = 1.99 → Moderate outlier",
                "composite_score = 2.00 → Strong outlier",
                "composite_score = 2.99 → Strong outlier",
                "composite_score = 3.00 → Extreme outlier",
                "composite_score = 5.50 → Extreme outlier"
              ]
            },
            "property_based_testing": {
              "using_proptest": "Generate random but valid inputs to test edge cases",
              "properties_to_test": [
                "Z-score is always finite for finite inputs with non-zero std_dev",
                "Composite score is always non-negative",
                "Higher absolute Z-scores produce higher composite scores",
                "Classification is consistent for identical Z-score patterns"
              ],
              "example_property_test": [
                "#[proptest]",
                "fn z_score_properties(mean: f64, std_dev in 0.1f64..100.0, value: f64) {",
                "    let z = calculate_z_score(value, mean, std_dev);",
                "    ",
                "    prop_assert!(z.is_finite());",
                "    prop_assert_eq!(calculate_z_score(mean, mean, std_dev), 0.0);",
                "}"
              ]
            },
            "integration_testing": {
              "full_pipeline_tests": [
                "Load test market data → calculate sector stats → detect outliers → verify end-to-end",
                "Test with real S&P 500 subset to ensure realistic results",
                "Performance test: 500 stocks across 11 sectors < 100ms"
              ]
            },
            "test_data_fixtures": {
              "mock_market_data": [
                "Technology sector: 5 stocks with known P/E, P/B, prices",
                "Healthcare sector: Mix of profitable and unprofitable stocks",
                "Energy sector: High volatility scenario",
                "Mixed sector: Boundary cases and edge conditions"
              ],
              "expected_results": "Pre-calculated expected Z-scores and classifications for fixture data"
            },
            "continuous_testing": {
              "github_actions": "Run tests on every commit and PR",
              "performance_benchmarks": "Track calculation performance over time",
              "coverage_reporting": "Ensure comprehensive test coverage"
            },
            "validation_steps": [
              "All Z-score calculations match manual verification",
              "Composite score formula produces expected results for known inputs",
              "Outlier classification logic correctly categorizes test cases",
              "Significance thresholds work at boundary conditions",
              "Edge cases (zero std_dev, missing data) handled gracefully",
              "Property-based tests pass for wide range of random inputs",
              "Performance tests complete within time limits",
              "Test coverage exceeds 90% for outlier detection module",
              "Integration tests verify end-to-end mathematical accuracy"
            ]
          }
        },
        {
          "id": "US019",
          "title": "As a developer, I want comprehensive unit tests for stock discovery functionality",
          "description": "Ensure stock discovery from Wikipedia and sector mapping logic are robust and reliable",
          "acceptance_criteria": [
            "Sector name mapping correctly transforms Wikipedia names to internal symbols",
            "Wikipedia HTML table parsing handles various table formats and edge cases",
            "Mock Wikipedia responses produce expected stock lists",
            "Error handling works for malformed HTML, missing columns, network failures",
            "Sector mapping handles case variations and alternate naming conventions",
            "Performance tests ensure parsing completes within acceptable time limits",
            "Test coverage > 90% for stock_discovery.rs module"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US005"],
          "status": "Not Started",
          "implementation_details": {
            "testing_framework": {
              "rust_testing": "Built-in Rust testing with #[cfg(test)] modules in stock_discovery.rs",
              "additional_crates": [
                "scraper = \"0.20\" # HTML parsing testing",
                "mockito = \"1.0\" # HTTP mocking for Wikipedia responses"
              ],
              "test_organization": "Tests in src/stock_discovery.rs with #[cfg(test)] mod tests"
            },
            "sector_mapping_testing": {
              "mapping_correctness": {
                "test_cases": [
                  "\"Information Technology\" → \"XLK\"",
                  "\"Health Care\" → \"XLV\"", 
                  "\"Financials\" → \"XLF\"",
                  "\"Consumer Discretionary\" → \"XLY\"",
                  "\"Communication Services\" → \"XLC\"",
                  "\"Industrials\" → \"XLI\"",
                  "\"Consumer Staples\" → \"XLP\"",
                  "\"Energy\" → \"XLE\"",
                  "\"Utilities\" → \"XLU\"",
                  "\"Real Estate\" → \"XLRE\"",
                  "\"Materials\" → \"XLB\""
                ],
                "implementation_example": [
                  "#[test]",
                  "fn test_sector_name_mapping() {",
                  "    assert_eq!(map_sector_name(\"Information Technology\"), Some(\"XLK\".to_string()));",
                  "    assert_eq!(map_sector_name(\"Health Care\"), Some(\"XLV\".to_string()));",
                  "    assert_eq!(map_sector_name(\"Unknown Sector\"), None);",
                  "}"
                ]
              },
              "edge_cases": {
                "case_variations": [
                  "\"information technology\" → \"XLK\" (lowercase)",
                  "\"INFORMATION TECHNOLOGY\" → \"XLK\" (uppercase)",
                  "\"Information  Technology\" → \"XLK\" (extra spaces)"
                ],
                "alternate_names": [
                  "\"IT\" → \"XLK\" (abbreviation)",
                  "\"Tech\" → \"XLK\" (common shorthand)",
                  "\"Healthcare\" → \"XLV\" (one word vs two)"
                ],
                "unmapped_sectors": "Return None for unrecognized sector names"
              }
            },
            "wikipedia_parsing_testing": {
              "html_fixtures": {
                "valid_table": [
                  "Mock HTML with proper S&P 500 table structure:",
                  "<table class=\"wikitable\">",
                  "<tr><th>Symbol</th><th>Security</th><th>GICS Sector</th></tr>",
                  "<tr><td>AAPL</td><td>Apple Inc.</td><td>Information Technology</td></tr>",
                  "<tr><td>MSFT</td><td>Microsoft Corporation</td><td>Information Technology</td></tr>",
                  "</table>"
                ],
                "expected_output": [
                  "Vec<Stock> with:",
                  "Stock { symbol: \"AAPL\", name: \"Apple Inc.\", sector_symbol: \"XLK\" }",
                  "Stock { symbol: \"MSFT\", name: \"Microsoft Corporation\", sector_symbol: \"XLK\" }"
                ]
              },
              "parsing_scenarios": [
                {
                  "description": "Standard Wikipedia S&P 500 table",
                  "html_structure": "Standard wikitable with Symbol, Security, GICS Sector columns",
                  "expected_count": "~500 stocks parsed correctly"
                },
                {
                  "description": "Table with extra columns",
                  "html_structure": "Additional columns like Date Added, Market Cap, etc.",
                  "expected_behavior": "Parse correctly, ignore extra columns"
                },
                {
                  "description": "Malformed table rows",
                  "html_structure": "Missing cells, empty rows, header variations",
                  "expected_behavior": "Skip malformed rows, continue parsing valid ones"
                },
                {
                  "description": "Special characters in company names",
                  "html_structure": "Names with &amp;, quotes, unicode characters",
                  "expected_behavior": "Properly decode HTML entities"
                }
              ]
            },
            "http_mocking": {
              "mock_wikipedia_responses": {
                "successful_response": [
                  "Mock HTTP 200 with valid S&P 500 Wikipedia HTML",
                  "Test full parsing pipeline from HTTP request to Stock list"
                ],
                "network_failures": [
                  "Mock HTTP 404, 500, timeout errors",
                  "Ensure graceful error handling and fallback behavior"
                ],
                "malformed_responses": [
                  "Mock response with invalid HTML",
                  "Response with no tables found", 
                  "Response with tables but wrong structure"
                ]
              },
              "mockito_usage": [
                "#[test]",
                "fn test_fetch_sp500_success() {",
                "    let _m = mockito::mock(\"GET\", \"/wiki/List_of_S%26P_500_companies\")",
                "        .with_status(200)",
                "        .with_header(\"content-type\", \"text/html\")",
                "        .with_body(MOCK_WIKIPEDIA_HTML)",
                "        .create();",
                "    ",
                "    let result = fetch_sp500_constituents().await;",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().len(), 2); // Based on mock data",
                "}"
              ]
            },
            "error_handling_testing": {
              "parsing_errors": [
                "HTML with no tables → return empty Vec",
                "Tables with missing required columns → skip those rows",
                "Invalid sector names → map to None, handle gracefully"
              ],
              "network_errors": [
                "HTTP timeout → return appropriate error",
                "DNS failure → return network error",
                "Invalid URL → return URL error"
              ],
              "data_validation": [
                "Empty stock symbol → skip row", 
                "Duplicate symbols → handle appropriately",
                "Invalid characters in symbols → sanitize or skip"
              ]
            },
            "performance_testing": {
              "parsing_benchmarks": [
                "Parse mock HTML with 500 stocks < 100ms",
                "Sector mapping for 500 stocks < 10ms",
                "Memory usage reasonable for large HTML responses"
              ],
              "stress_testing": [
                "Large HTML documents (multiple MB)",
                "Tables with thousands of rows",
                "Malformed HTML with deeply nested structures"
              ]
            },
            "integration_testing": {
              "end_to_end_pipeline": [
                "Mock Wikipedia → Parse HTML → Map sectors → Return Stock list",
                "Verify integration with database insertion logic",
                "Test with real Wikipedia structure (sample, not live calls)"
              ]
            },
            "test_data_fixtures": {
              "wikipedia_html_samples": [
                "MOCK_SP500_STANDARD: Standard table with ~10 stocks",
                "MOCK_SP500_MALFORMED: Missing cells, extra columns",
                "MOCK_SP500_SPECIAL_CHARS: Companies with &, quotes, unicode",
                "MOCK_SP500_EMPTY: Valid HTML but no stock data"
              ],
              "expected_results": [
                "Pre-defined Stock structs for each mock HTML fixture",
                "Expected sector mappings for test verification",
                "Error cases with expected error types"
              ]
            },
            "regression_testing": {
              "wikipedia_format_changes": [
                "Test against archived Wikipedia HTML from different dates",
                "Ensure parsing remains robust to minor format changes",
                "Document assumptions about Wikipedia table structure"
              ]
            },
            "validation_steps": [
              "All sector name mappings work correctly for GICS standard names",
              "Wikipedia table parsing handles standard S&P 500 table format",
              "Mock HTML fixtures produce expected Stock lists",
              "Error handling gracefully manages malformed HTML and network issues",
              "Case variations and alternate sector names map correctly",
              "Performance tests complete within acceptable time limits",
              "HTTP mocking properly simulates Wikipedia responses",
              "Edge cases (empty tables, missing columns) handled appropriately",
              "Test coverage exceeds 90% for stock discovery module",
              "Integration tests verify end-to-end stock discovery pipeline"
            ]
          }
        },
        {
          "id": "US009",
          "title": "As a user, I want to see comprehensive outlier analysis dashboard",
          "description": "Transform outlier detection results into actionable financial intelligence with detailed metrics and trends",
          "acceptance_criteria": [
            "Scrollable outlier list below sector grid showing multi-dimensional analysis",
            "Display composite outlier score, individual Z-scores (P/E, P/B, price, volume)",
            "Show outlier classification (undervalued, overvalued, momentum, etc.)",
            "Color-coded significance levels (moderate, strong, extreme outliers)",
            "Historical trend indicators (persistent vs new outliers)",
            "Click on outlier shows detailed drill-down with charts and context",
            "Sortable by different metrics (composite score, P/E Z-score, etc.)",
            "Filter options (outlier type, sector, significance level)"
          ],
          "complexity": "Large",
          "estimated_hours": 6,
          "dependencies": ["US008", "US018"],
          "status": "Not Started",
          "implementation_details": {
            "comprehensive_outlier_display": {
              "outlier_list_item": {
                "primary_info": [
                  "Stock symbol (AAPL) + company name (Apple Inc.)",
                  "Sector badge (Technology - XLK)",
                  "Composite outlier score (2.8σ with color coding)"
                ],
                "detailed_metrics": [
                  "P/E Z-score: -2.1σ (undervalued vs sector)",
                  "P/B Z-score: -1.8σ (trading below book value)",
                  "Price Z-score: +0.5σ (slight outperformance)",
                  "Volume Z-score: +3.2σ (unusual trading activity)"
                ],
                "outlier_classification": {
                  "type": "undervalued",
                  "confidence": "strong", 
                  "description": "Significantly undervalued on fundamentals despite recent price strength"
                },
                "trend_indicators": [
                  "↗ New outlier (first detected today)",
                  "🔥 Persistent outlier (detected 5+ days)",
                  "📈 Strengthening (outlier score increasing)",
                  "📉 Weakening (outlier score decreasing)"
                ]
              }
            },
            "interactive_features": {
              "sorting_options": [
                "Composite Score (strongest outliers first)",
                "P/E Z-Score (most undervalued first)",
                "P/B Z-Score (lowest book value multiples)",
                "Price Performance (biggest movers)",
                "Volume Anomaly (highest volume spikes)"
              ],
              "filtering_controls": [
                "Outlier Type: [All] [Undervalued] [Overvalued] [Momentum] [Value Trap]",
                "Significance: [All] [Moderate 1.5σ+] [Strong 2σ+] [Extreme 3σ+]",
                "Sector: [All] [Technology] [Healthcare] etc.",
                "Trend: [All] [New] [Persistent] [Strengthening] [Weakening]"
              ],
              "search_functionality": "Search by stock symbol or company name"
            },
            "drill_down_modal": {
              "triggered_by": "Click on any outlier in the list",
              "detailed_view_sections": {
                "stock_overview": [
                  "Company name, sector, market cap",
                  "Current price, price change, volume",
                  "Key ratios: P/E, P/B, dividend yield"
                ],
                "outlier_analysis": [
                  "Visual chart showing where stock sits vs sector distribution",
                  "Detailed Z-score breakdown with explanations",
                  "Composite score calculation transparency"
                ],
                "historical_trends": [
                  "7-day outlier score chart (from outlier_detections table)",
                  "Persistence indicator: 'Has been undervalued outlier for 12 days'",
                  "Score evolution: 'Outlier strength increasing from 2.1σ to 2.8σ'"
                ],
                "sector_context": [
                  "How this stock compares to sector averages",
                  "Sector performance summary",
                  "Other notable outliers in same sector"
                ],
                "actionable_insights": [
                  "Investment thesis: 'Strong fundamentals, unusual volume suggests institutional interest'",
                  "Risk factors: 'P/E compression possible if earnings disappoint'",
                  "Comparable stocks in other sectors with similar patterns"
                ]
              }
            },
            "visual_design": {
              "list_layout": {
                "item_height": "120px each for comprehensive information",
                "responsive_columns": [
                  "Stock info (symbol, name, sector) - 25%",
                  "Composite score with visual indicator - 15%", 
                  "Individual Z-scores grid - 35%",
                  "Classification & trends - 25%"
                ],
                "color_coding": {
                  "undervalued": "Green background tint",
                  "overvalued": "Red background tint",
                  "momentum": "Blue background tint",
                  "value_trap": "Orange background tint"
                }
              },
              "significance_indicators": [
                "1.5σ - 2σ: Orange dot (moderate)",
                "2σ - 3σ: Red dot (strong)", 
                "3σ+: Red exclamation mark (extreme)"
              ],
              "trend_icons": [
                "New: ✨ sparkle icon",
                "Persistent: 🔥 fire icon",
                "Strengthening: 📈 chart up",
                "Weakening: 📉 chart down"
              ]
            },
            "data_integration": {
              "tauri_commands": [
                "#[tauri::command]",
                "pub async fn get_all_outliers(threshold: f64) -> Result<Vec<OutlierSummary>, String>",
                "",
                "#[tauri::command]",
                "pub async fn get_outlier_details(stock_id: i32) -> Result<OutlierDetails, String>",
                "",
                "#[tauri::command]",
                "pub async fn get_outlier_history(stock_id: i32, days: i32) -> Result<Vec<OutlierHistoryPoint>, String>"
              ],
              "react_data_structures": [
                "interface OutlierSummary {",
                "  stock: Stock;",
                "  sector: Sector;", 
                "  composite_score: number;",
                "  z_scores: ZScores;",
                "  outlier_type: OutlierType;",
                "  significance_level: SignificanceLevel;",
                "  trend: OutlierTrend;",
                "  days_as_outlier: number;",
                "}"
              ]
            },
            "performance_considerations": {
              "pagination": "Load 50 outliers initially, infinite scroll for more",
              "virtualization": "Use react-window for smooth scrolling with many outliers",
              "caching": "Cache outlier list and only refresh on data update",
              "sorting_optimization": "Sort on backend, not frontend for large datasets"
            },
            "empty_states": {
              "no_outliers": "No outliers detected with current threshold. Try lowering sensitivity.",
              "loading_state": "Analyzing market data for outliers...",
              "error_state": "Failed to load outlier data. Check your connection and try refreshing."
            },
            "validation_steps": [
              "Outlier list displays comprehensive information for each stock",
              "Composite scores and individual Z-scores are accurate and match US008 calculations",
              "Outlier classifications make intuitive sense (undervalued stocks have low P/E + P/B)",
              "Historical trends work correctly (persistent outliers show fire icon)",
              "Sorting and filtering controls work smoothly",
              "Drill-down modal provides detailed analysis and charts",
              "Color coding helps quickly identify outlier types",
              "Performance remains smooth with 100+ outliers",
              "Empty states and loading states provide good user experience"
            ]
          }
        }
      ]
    },
    "epic_4_advanced_features": {
      "title": "Advanced Analytics",
      "priority": "P1",
      "stories": [
        {
          "id": "US010",
          "title": "As a user, I want configurable outlier thresholds",
          "description": "Allow users to adjust sensitivity of outlier detection",
          "acceptance_criteria": [
            "Settings panel with threshold slider (1.0σ - 3.0σ)",
            "Outlier detection updates in real-time as threshold changes",
            "Settings persist between app sessions",
            "Visual feedback shows how many outliers at each threshold"
          ],
          "complexity": "Medium",
          "estimated_hours": 5,
          "dependencies": ["US009"],
          "status": "Not Started"
        },
        {
          "id": "US011",
          "title": "As a user, I want multiple outlier metrics",
          "description": "Detect outliers based on volume, P/E ratio, market cap, not just price",
          "acceptance_criteria": [
            "Volume outlier detection",
            "P/E ratio outlier detection", 
            "Market cap outlier detection",
            "User can select which metrics to analyze",
            "Combined outlier score across multiple metrics"
          ],
          "complexity": "Large",
          "estimated_hours": 8,
          "dependencies": ["US010"],
          "status": "Not Started"
        },
        {
          "id": "US012",
          "title": "As a user, I want historical outlier analysis",
          "description": "See how current outliers performed over past periods",
          "acceptance_criteria": [
            "Store historical market data (1 week minimum)",
            "Show outlier performance over 1d, 3d, 7d periods",
            "Highlight consistently strong/weak outliers",
            "Performance attribution vs sector average"
          ],
          "complexity": "Large",
          "estimated_hours": 10,
          "dependencies": ["US011"],
          "status": "Not Started"
        },
        {
          "id": "US017",
          "title": "As a user, I want to analyze Russell 2000 small-cap stocks with tailored metrics",
          "description": "Integrate Russell 2000 universe with small-cap-specific analysis and outlier detection",
          "acceptance_criteria": [
            "Toggle between S&P 500 (large-cap) and Russell 2000 (small-cap) analysis modes",
            "Fetch Russell 2000 constituents from iShares IWM ETF holdings",
            "Apply small-cap-specific outlier detection with adjusted thresholds",
            "Handle higher volatility and frequent missing P/E ratios appropriately", 
            "Display small-cap vs large-cap comparative analysis",
            "Show liquidity-adjusted metrics (volume relative to float)",
            "Separate sector distributions for small-cap vs large-cap"
          ],
          "complexity": "Large", 
          "estimated_hours": 10,
          "dependencies": ["US008", "US009"],
          "status": "Not Started",
          "implementation_details": {
            "small_cap_characteristics": {
              "key_differences": [
                "Higher volatility - normal swings are 2-3x larger than large-caps",
                "Less liquidity - many trade <100k shares/day vs millions for large-caps",
                "Frequent unprofitability - 30-40% may lack meaningful P/E ratios",
                "Growth-oriented - often sacrifice current profits for growth",
                "Economic sensitivity - more affected by interest rates and economic cycles",
                "Less analyst coverage - fewer professional estimates and research"
              ],
              "adjusted_analysis_approach": [
                "Use higher Z-score thresholds (2.0σ vs 1.5σ for large-caps)",
                "Focus on P/B, P/S ratios when P/E unavailable", 
                "Emphasize volume and liquidity anomalies",
                "Consider revenue growth rates over earnings",
                "Weight volatility metrics more heavily"
              ]
            },
            "data_integration": {
              "russell_2000_sourcing": {
                "primary_source": "iShares IWM ETF holdings data",
                "backup_sources": ["FTSE Russell official data", "Financial data providers"],
                "update_frequency": "Monthly (Russell reconstitutes quarterly but holdings change)",
                "data_quality_considerations": [
                  "IWM may not hold exactly 2000 stocks (varies 1900-2100)",
                  "Holdings percentages are small (0.01-0.5% typically)",
                  "Some stocks may not have complete fundamental data"
                ]
              },
              "database_schema_additions": {
                "stock_universe_table": [
                  "CREATE TABLE stock_universe (",
                  "  id INTEGER PRIMARY KEY,",
                  "  stock_id INTEGER NOT NULL REFERENCES stocks(id),", 
                  "  universe_type TEXT NOT NULL, -- 'sp500', 'russell2000'",
                  "  date_added DATE NOT NULL,",
                  "  date_removed DATE, -- NULL if still active",
                  "  INDEX idx_universe_type_active (universe_type, date_removed)",
                  ");"
                ],
                "universe_specific_stats": [
                  "ALTER TABLE sector_stats_daily ADD COLUMN universe_type TEXT NOT NULL DEFAULT 'sp500';",
                  "ALTER TABLE outlier_detections ADD COLUMN universe_type TEXT NOT NULL DEFAULT 'sp500';"
                ]
              }
            },
            "tailored_outlier_detection": {
              "small_cap_thresholds": {
                "volatility_adjustment": "Use 2.0σ threshold vs 1.5σ for large-caps",
                "sector_specific": {
                  "technology": "2.5σ (higher volatility in small-cap tech)",
                  "healthcare": "2.2σ (biotech volatility)", 
                  "financials": "1.8σ (regional banks more stable)",
                  "energy": "3.0σ (exploration companies very volatile)"
                }
              },
              "alternative_metrics": {
                "when_pe_unavailable": [
                  "Price-to-Sales (P/S) ratio analysis",
                  "Price-to-Book (P/B) remains important",  
                  "Revenue growth rate outliers",
                  "Enterprise Value to Revenue (EV/R)"
                ],
                "liquidity_metrics": [
                  "Volume-to-float ratio (trading volume vs available shares)",
                  "Bid-ask spread analysis (when available)",
                  "Average daily dollar volume"
                ]
              },
              "composite_scoring_adjustments": {
                "small_cap_formula": "weighted_score = (p_s_z * 0.25) + (p_b_z * 0.25) + (volume_z * 0.3) + (volatility_z * 0.2)",
                "missing_data_handling": "Require at least 2 valid metrics for composite score (vs 3 for large-caps)"
              }
            },
            "user_interface_design": {
              "universe_toggle": {
                "location": "Header next to refresh button",
                "design": "Toggle switch: [S&P 500] / [Russell 2000]",
                "state_persistence": "Remember user preference between sessions"
              },
              "comparative_mode": {
                "side_by_side": "Option to show large-cap vs small-cap sector performance",
                "outlier_comparison": "Highlight different outlier patterns between universes",
                "volatility_indicators": "Visual cues for higher small-cap volatility"
              },
              "sector_grid_adaptations": {
                "small_cap_indicators": [
                  "Different color scheme (blue tint vs current)",
                  "Volatility warning icons for high-volatility sectors",
                  "Missing data indicators (e.g., '45% have P/E data')"
                ],
                "metrics_display": [
                  "Show P/S when P/E unavailable",
                  "Liquidity indicators (avg daily volume)",
                  "Growth rate emphasis over absolute values"
                ]
              }
            },
            "data_fetching_implementation": {
              "iwm_holdings_scraper": {
                "rust_implementation": [
                  "// Fetch IWM holdings from iShares",
                  "pub async fn fetch_russell_2000() -> Result<Vec<String>, String> {",
                  "    let client = reqwest::Client::new();",
                  "    ",
                  "    // Primary: iShares CSV download",
                  "    let url = \"https://www.ishares.com/us/products/239710/ishares-russell-2000-etf/1467271812596.ajax?fileType=csv\";",
                  "    ",
                  "    match client.get(url).send().await {",
                  "        Ok(response) => {",
                  "            let csv_text = response.text().await?;",
                  "            parse_ishares_csv(csv_text)",
                  "        },",
                  "        Err(_) => {",
                  "            // Fallback: scrape holdings page", 
                  "            fetch_russell_fallback().await",
                  "        }",
                  "    }",
                  "}"
                ],
                "error_handling": [
                  "Graceful fallback if iShares blocks scraping",
                  "Cache last successful Russell 2000 list",  
                  "User notification when data is stale"
                ]
              }
            },
            "performance_considerations": {
              "data_volume": "Russell 2000 = 2000 stocks vs S&P 500 = 500 stocks (4x data)",
              "api_rate_limits": "Stagger API calls to avoid overwhelming Yahoo Finance",
              "database_indexing": "Ensure universe_type is indexed for fast filtering",
              "ui_responsiveness": "Use pagination/virtualization for large outlier lists"
            },
            "analytical_insights": {
              "cross_universe_comparisons": [
                "Small-cap vs large-cap sector rotation patterns",
                "Volatility arbitrage opportunities",
                "Liquidity premium analysis",
                "Growth vs value performance differences"
              ],
              "unique_small_cap_outliers": [
                "Micro-caps with institutional accumulation (volume spikes)",
                "Growth companies with negative P/E but strong revenue",
                "Regional plays with local market advantages",
                "Acquisition targets with unusual valuation metrics"
              ]
            },
            "validation_steps": [
              "Successfully fetch ~2000 Russell 2000 constituents from IWM",
              "Universe toggle works smoothly between S&P 500 and Russell 2000",
              "Small-cap outlier detection uses appropriate higher thresholds",
              "Missing P/E ratios handled gracefully (use P/S, P/B alternatives)",
              "Comparative analysis shows meaningful differences between universes",
              "Performance remains acceptable with 4x more stocks",
              "Sector distributions reflect small-cap vs large-cap differences",
              "UI clearly distinguishes between small-cap and large-cap analysis modes"
            ]
          }
        }
      ]
    },
    "epic_5_polish": {
      "title": "User Experience & Polish",
      "priority": "P2", 
      "stories": [
        {
          "id": "US013",
          "title": "As a user, I want the app to look professional",
          "description": "Improve styling, animations, and visual design",
          "acceptance_criteria": [
            "Consistent color scheme and typography",
            "Smooth animations for data updates",
            "Professional-looking sector cards with charts",
            "Dark/light theme support",
            "Loading states and progress indicators"
          ],
          "complexity": "Medium",
          "estimated_hours": 6,
          "dependencies": ["US009"],
          "status": "Not Started"
        },
        {
          "id": "US014",
          "title": "As a user, I want to export outlier data",
          "description": "Export current outliers to CSV or JSON for further analysis", 
          "acceptance_criteria": [
            "Export button in toolbar",
            "CSV format with all outlier details",
            "JSON format for programmatic use",
            "File saved to user's Downloads folder",
            "Timestamp in filename"
          ],
          "complexity": "Small",
          "estimated_hours": 3,
          "dependencies": ["US013"],
          "status": "Not Started"
        },
        {
          "id": "US015",
          "title": "As a user, I want automatic data refresh",
          "description": "App automatically refreshes during market hours",
          "acceptance_criteria": [
            "Auto-refresh every 15 minutes during market hours (9:30am-4pm ET)",
            "Pause auto-refresh outside market hours",
            "User can disable/configure auto-refresh",
            "Visual indicator shows time until next refresh",
            "Respect API rate limits"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US013"],
          "status": "Not Started"
        },
        {
          "id": "US016",
          "title": "As a user, I want to manage historical data storage",
          "description": "Control database size by cleaning up old outlier detection data",
          "acceptance_criteria": [
            "Settings panel shows current database size and record counts",
            "User can set data retention policy (30d, 90d, 1yr, unlimited)",
            "Manual 'Clean Old Data' button to free up space immediately",
            "Automatic cleanup based on retention policy",
            "Preserve summary statistics while removing detailed records",
            "Warning before deleting historical data"
          ],
          "complexity": "Medium",
          "estimated_hours": 5,
          "dependencies": ["US008"],
          "status": "Not Started",
          "implementation_details": {
            "data_lifecycle_strategy": {
              "retention_tiers": {
                "detailed_data": "Keep full outlier_detections records for user-selected period (default 90 days)",
                "summary_data": "Aggregate to weekly/monthly summaries for longer-term trends",
                "market_data": "Keep latest snapshot + historical price changes (configurable retention)"
              },
              "cleanup_operations": [
                "DELETE FROM outlier_detections WHERE detection_date < (CURRENT_DATE - retention_days)",
                "DELETE FROM market_data WHERE timestamp < (CURRENT_TIMESTAMP - retention_days * 24 * 60 * 60)",
                "VACUUM database to reclaim disk space after cleanup"
              ]
            },
            "user_interface": {
              "settings_panel_section": {
                "database_overview": [
                  "Current database size: 15.3 MB",
                  "Outlier records: 12,450 (last 90 days)",
                  "Market data records: 8,200 (last 30 days)",
                  "Oldest data: March 15, 2025"
                ],
                "retention_settings": [
                  "Data retention period: [30d] [90d] [1yr] [Unlimited]",
                  "Auto-cleanup enabled: [✓]",
                  "Cleanup frequency: [Daily] [Weekly] [Monthly]"
                ],
                "manual_controls": [
                  "[Clean Old Data Now] button with confirmation dialog",
                  "[Export Historical Data] before cleanup",
                  "[Reset All Data] nuclear option with multiple confirmations"
                ]
              }
            },
            "smart_cleanup_logic": {
              "preserve_significant_outliers": "Keep records of extreme outliers (3σ+) longer than moderate ones",
              "summarization_before_delete": [
                "Create monthly summary: sector, avg_outlier_count, strongest_outlier_score",
                "Store trend data: outlier_counts_over_time for charts"
              ],
              "gradual_degradation": [
                "0-30 days: Keep all detailed records",
                "30-90 days: Keep daily summaries", 
                "90d-1yr: Keep weekly summaries",
                "1yr+: Keep monthly summaries only"
              ]
            },
            "database_monitoring": {
              "size_tracking": "Monitor database file size and warn at configurable thresholds",
              "performance_impact": "Show query performance degradation as data grows",
              "storage_breakdown": "Show space used by each table type"
            },
            "export_before_cleanup": {
              "csv_export": "Export outlier history to CSV before deletion",
              "json_export": "Export full data structure for backup/analysis", 
              "selective_export": "User can choose date ranges and specific stocks"
            },
            "validation_steps": [
              "Settings panel shows accurate database size and record counts",
              "Data retention settings persist between app sessions",
              "Manual cleanup removes correct data based on retention policy",
              "Auto-cleanup runs on schedule without user intervention",
              "Database size decreases after cleanup operation",
              "Export functionality works before cleanup",
              "Confirmation dialogs prevent accidental data loss",
              "Summary statistics preserved even after detailed data cleanup"
            ]
          }
        }
      ]
    }
  },
  "technical_tasks": {
    "infrastructure": [
      {
        "id": "TECH001",
        "title": "Setup Tauri project structure",
        "description": "Initialize Tauri app with React frontend",
        "priority": "P0",
        "complexity": "Small",
        "estimated_hours": 1,
        "dependencies": [],
        "related_stories": ["US001"],
        "status": "Not Started"
      },
      {
        "id": "TECH002", 
        "title": "Configure TypeScript and build tools",
        "description": "Setup TS, linting, formatting, build pipeline",
        "priority": "P0",
        "complexity": "Small",
        "estimated_hours": 2,
        "dependencies": ["TECH001"],
        "related_stories": ["US001"],
        "status": "Not Started"
      },
      {
        "id": "TECH003",
        "title": "Setup SQLite with migrations",
        "description": "Database initialization and schema management",
        "priority": "P0", 
        "complexity": "Medium",
        "estimated_hours": 3,
        "dependencies": ["TECH001"],
        "related_stories": ["US004"],
        "status": "Not Started"
      }
    ],
    "data_integration": [
      {
        "id": "TECH004",
        "title": "Yahoo Finance API client",
        "description": "Rust HTTP client for fetching market data",
        "priority": "P1",
        "complexity": "Large",
        "estimated_hours": 5,
        "dependencies": ["TECH003"],
        "related_stories": ["US007"],
        "status": "Not Started"
      },
      {
        "id": "TECH005",
        "title": "Statistical analysis module",
        "description": "Outlier detection algorithms in Rust",
        "priority": "P1",
        "complexity": "Large", 
        "estimated_hours": 6,
        "dependencies": ["TECH004"],
        "related_stories": ["US008", "US011"],
        "status": "Not Started"
      },
      {
        "id": "TECH006",
        "title": "Data caching and persistence",
        "description": "Efficient data storage and retrieval strategies",
        "priority": "P1",
        "complexity": "Medium",
        "estimated_hours": 4,
        "dependencies": ["TECH004"],
        "related_stories": ["US012"],
        "status": "Not Started"
      }
    ]
  },
  "milestones": [
    {
      "name": "MVP Demo",
      "target_date": "2025-02-15",
      "description": "Basic app with sector grid and mock data",
      "required_stories": ["US001", "US002", "US003"],
      "status": "Planned"
    },
    {
      "name": "Alpha Release",
      "target_date": "2025-03-01", 
      "description": "Working outlier detection with real data",
      "required_stories": ["US004", "US005", "US006", "US007", "US008", "US018", "US019", "US009"],
      "status": "Planned"
    },
    {
      "name": "Beta Release",
      "target_date": "2025-03-15",
      "description": "Advanced features and polish",
      "required_stories": ["US010", "US011", "US013", "US014"],
      "status": "Planned"
    },
    {
      "name": "Portfolio Ready", 
      "target_date": "2025-03-30",
      "description": "Production-ready app for job applications",
      "required_stories": ["US012", "US015", "US016"],
      "status": "Planned"
    },
    {
      "name": "Multi-Universe Platform",
      "target_date": "2025-04-15", 
      "description": "Comprehensive large-cap and small-cap analysis platform",
      "required_stories": ["US017"],
      "status": "Future Enhancement"
    }
  ],
  "success_metrics": [
    {
      "metric": "App Launch Time",
      "target": "< 2 seconds",
      "current": "N/A"
    },
    {
      "metric": "Data Refresh Speed", 
      "target": "< 10 seconds",
      "current": "N/A"
    },
    {
      "metric": "Memory Usage",
      "target": "< 100MB",
      "current": "N/A"
    },
    {
      "metric": "Bundle Size",
      "target": "< 15MB", 
      "current": "N/A"
    }
  ],
  "risks": [
    {
      "risk": "API Rate Limits",
      "impact": "High",
      "probability": "Medium",
      "mitigation": "Implement caching, use multiple data sources, respect rate limits"
    },
    {
      "risk": "Market Data Quality",
      "impact": "Medium", 
      "probability": "Low",
      "mitigation": "Data validation, multiple sources, graceful degradation"
    },
    {
      "risk": "Cross-platform Compatibility",
      "impact": "Low",
      "probability": "Low", 
      "mitigation": "Focus on macOS first, Tauri handles most cross-platform issues"
    },
    {
      "risk": "Russell 2000 Data Complexity",
      "impact": "Medium",
      "probability": "Medium",
      "mitigation": "Higher volatility thresholds, robust missing data handling, iShares ETF backup sources"
    },
    {
      "risk": "Mathematical Accuracy in Financial Calculations",
      "impact": "High",
      "probability": "Low",
      "mitigation": "Comprehensive unit testing, property-based testing, manual verification of calculations"
    },
    {
      "risk": "Wikipedia Format Changes Breaking Stock Discovery",
      "impact": "Medium",
      "probability": "Medium",
      "mitigation": "Comprehensive parsing tests, mock HTML fixtures, robust error handling, fallback data sources"
    }
  ],
  "notes": {
    "last_updated": "2025-01-23",
    "next_review": "2025-01-30",
    "team_size": "1 developer + AI assistants",
    "budget": "Free tier APIs, $0 budget constraint"
  }
}