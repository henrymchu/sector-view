{
  "product": {
    "name": "Sector View",
    "version": "1.0.0",
    "description": "Desktop application for S&P 500 sector analysis and outlier detection",
    "target_platform": "macOS",
    "tech_stack": ["Tauri", "Rust", "React", "TypeScript", "SQLite", "Python"]
  },
  "user_personas": [
    {
      "name": "Day Trader",
      "description": "Active trader looking for quick sector outlier opportunities",
      "goals": ["Find undervalued stocks", "Identify momentum plays", "React to market changes quickly"]
    },
    {
      "name": "Portfolio Manager", 
      "description": "Professional managing diversified portfolios",
      "goals": ["Sector rotation strategies", "Risk management", "Performance attribution"]
    },
    {
      "name": "Job Seeker",
      "description": "Developer showcasing technical skills",
      "goals": ["Demonstrate full-stack abilities", "Show financial domain knowledge", "Create impressive portfolio piece"]
    }
  ],
  "user_stories": {
    "epic_1_basic_ui": {
      "title": "Basic Application Shell",
      "priority": "P0",
      "stories": [
        {
          "id": "US001",
          "title": "As a user, I want to launch the desktop app",
          "description": "Create basic Tauri app that opens a window with React frontend",
          "acceptance_criteria": [
            "App launches without errors",
            "Window is resizable and proper size (1200x800)",
            "Shows 'Sector View' title",
            "App icon appears in dock"
          ],
          "complexity": "Small",
          "estimated_hours": 2,
          "dependencies": [],
          "status": "Not Started",
          "implementation_details": {
            "setup_commands": [
              "cd /Users/collettemilton/code/sector-view",
              "npm create tauri-app@latest .",
              "Choose: React + TypeScript template",
              "Configure app name: 'Sector View'"
            ],
            "key_files": {
              "src-tauri/tauri.conf.json": {
                "description": "Configure window settings and app metadata",
                "key_changes": [
                  "Set productName to 'Sector View'",
                  "Set window title to 'Sector View'", 
                  "Set window dimensions: 1200x800",
                  "Set minWidth: 800, minHeight: 600"
                ]
              },
              "src/App.tsx": {
                "description": "Basic React component showing app title",
                "key_changes": [
                  "Replace default content with 'Sector View' heading",
                  "Add basic CSS styling for clean appearance"
                ]
              }
            },
            "testing_commands": [
              "npm run tauri dev - launch in development mode",
              "npm run tauri build - create production bundle",
              "Verify bundle size < 15MB"
            ],
            "validation_steps": [
              "App launches without console errors",
              "Window opens at 1200x800 dimensions",
              "Window is resizable with proper min dimensions",
              "Title bar displays 'Sector View'",
              "App icon appears in macOS dock",
              "UI shows clean, minimal interface ready for next story"
            ]
          }
        },
        {
          "id": "US002", 
          "title": "As a user, I want to see a basic sector grid layout",
          "description": "Create React components for displaying 11 GICS sectors in a grid",
          "acceptance_criteria": [
            "3x4 grid layout with 11 sector cards (1 empty slot for symmetry)",
            "Each card shows sector name and symbol (e.g., 'Technology (XLK)')",
            "Cards have consistent styling with hover effects",
            "Grid is responsive to window resizing",
            "Placeholder data shows until real data loads"
          ],
          "complexity": "Small",
          "estimated_hours": 3,
          "dependencies": ["US001"],
          "status": "Not Started",
          "implementation_details": {
            "ui_design": {
              "layout": "CSS Grid with 4 columns, auto rows",
              "card_size": "280px width, 180px height (approximate)",
              "spacing": "16px gaps between cards",
              "responsive_breakpoints": [
                "< 1000px: 3 columns",
                "< 800px: 2 columns", 
                "< 500px: 1 column"
              ]
            },
            "component_structure": {
              "src/components/SectorGrid.tsx": {
                "description": "Main container component that fetches and displays all sectors",
                "responsibilities": [
                  "Fetch sectors using useDatabase hook",
                  "Handle loading and error states",
                  "Render grid of SectorCard components"
                ],
                "example_jsx": [
                  "const SectorGrid = () => {",
                  "  const { getSectors } = useDatabase();",
                  "  const [sectors, setSectors] = useState<Sector[]>([]);",
                  "  const [loading, setLoading] = useState(true);",
                  "",
                  "  useEffect(() => {",
                  "    const loadSectors = async () => {",
                  "      try {",
                  "        const data = await getSectors();",
                  "        setSectors(data);",
                  "      } catch (error) {",
                  "        console.error('Failed to load sectors:', error);",
                  "      } finally {",
                  "        setLoading(false);",
                  "      }",
                  "    };",
                  "    loadSectors();",
                  "  }, []);",
                  "",
                  "  if (loading) return <div className=\"loading\">Loading sectors...</div>;",
                  "",
                  "  return (",
                  "    <div className=\"sector-grid\">",
                  "      {sectors.map(sector => (",
                  "        <SectorCard key={sector.id} sector={sector} />",
                  "      ))}",
                  "    </div>",
                  "  );",
                  "};"
                ]
              },
              "src/components/SectorCard.tsx": {
                "description": "Individual sector card component",
                "props": "{ sector: Sector }",
                "example_jsx": [
                  "interface SectorCardProps {",
                  "  sector: Sector;",
                  "}",
                  "",
                  "const SectorCard = ({ sector }: SectorCardProps) => {",
                  "  return (",
                  "    <div className=\"sector-card\">",
                  "      <div className=\"sector-header\">",
                  "        <h3 className=\"sector-name\">{sector.name}</h3>",
                  "        <span className=\"sector-symbol\">({sector.symbol})</span>",
                  "      </div>",
                  "      <div className=\"sector-metrics\">",
                  "        <div className=\"metric\">",
                  "          <span className=\"metric-label\">Change:</span>",
                  "          <span className=\"metric-value placeholder\">--</span>",
                  "        </div>",
                  "        <div className=\"metric\">",
                  "          <span className=\"metric-label\">Outliers:</span>",
                  "          <span className=\"metric-value placeholder\">--</span>",
                  "        </div>",
                  "      </div>",
                  "    </div>",
                  "  );",
                  "};"
                ]
              }
            },
            "css_styling": {
              "src/styles/SectorGrid.css": {
                "description": "Grid layout and responsive behavior",
                "key_styles": [
                  ".sector-grid {",
                  "  display: grid;",
                  "  grid-template-columns: repeat(4, 1fr);",
                  "  gap: 16px;",
                  "  padding: 20px;",
                  "  max-width: 1200px;",
                  "  margin: 0 auto;",
                  "}",
                  "",
                  "@media (max-width: 1000px) {",
                  "  .sector-grid {",
                  "    grid-template-columns: repeat(3, 1fr);",
                  "  }",
                  "}",
                  "",
                  "@media (max-width: 800px) {",
                  "  .sector-grid {",
                  "    grid-template-columns: repeat(2, 1fr);",
                  "  }",
                  "}",
                  "",
                  "@media (max-width: 500px) {",
                  "  .sector-grid {",
                  "    grid-template-columns: 1fr;",
                  "  }",
                  "}"
                ]
              },
              "src/styles/SectorCard.css": {
                "description": "Individual card styling with hover effects",
                "key_styles": [
                  ".sector-card {",
                  "  background: #ffffff;",
                  "  border: 1px solid #e2e8f0;",
                  "  border-radius: 8px;",
                  "  padding: 20px;",
                  "  box-shadow: 0 1px 3px rgba(0,0,0,0.1);",
                  "  transition: all 0.2s ease;",
                  "  cursor: pointer;",
                  "}",
                  "",
                  ".sector-card:hover {",
                  "  transform: translateY(-2px);",
                  "  box-shadow: 0 4px 12px rgba(0,0,0,0.15);",
                  "  border-color: #3b82f6;",
                  "}",
                  "",
                  ".sector-header {",
                  "  margin-bottom: 16px;",
                  "}",
                  "",
                  ".sector-name {",
                  "  font-size: 18px;",
                  "  font-weight: 600;",
                  "  margin: 0 0 4px 0;",
                  "  color: #1f2937;",
                  "}",
                  "",
                  ".sector-symbol {",
                  "  font-size: 14px;",
                  "  color: #6b7280;",
                  "  font-weight: 500;",
                  "}",
                  "",
                  ".sector-metrics {",
                  "  display: flex;",
                  "  flex-direction: column;",
                  "  gap: 8px;",
                  "}",
                  "",
                  ".metric {",
                  "  display: flex;",
                  "  justify-content: space-between;",
                  "  align-items: center;",
                  "}",
                  "",
                  ".metric-label {",
                  "  font-size: 14px;",
                  "  color: #6b7280;",
                  "}",
                  "",
                  ".metric-value {",
                  "  font-size: 16px;",
                  "  font-weight: 600;",
                  "}",
                  "",
                  ".metric-value.placeholder {",
                  "  color: #d1d5db;",
                  "}"
                ]
              }
            },
            "mock_data_approach": {
              "during_development": "Use hardcoded array of 11 sectors for initial testing",
              "example_mock_data": [
                "const mockSectors: Sector[] = [",
                "  { id: 1, name: 'Information Technology', symbol: 'XLK' },",
                "  { id: 2, name: 'Health Care', symbol: 'XLV' },",
                "  // ... rest of sectors",
                "];",
                "",
                "// Replace with real useDatabase call later"
              ],
              "placeholder_content": "Show '--' for metrics that will be populated in US007"
            },
            "integration_points": {
              "us006_connection": "Uses useDatabase hook from US006 to fetch real sector data",
              "us007_preparation": "Cards have placeholder areas for price change and outlier counts",
              "future_interactivity": "Cards are clickable (hover effects) for future drill-down features"
            },
            "accessibility": [
              "Proper heading hierarchy (h3 for sector names)",
              "Sufficient color contrast for text",
              "Keyboard navigation support (focus states)",
              "Screen reader friendly labels"
            ],
            "validation_steps": [
              "Grid displays 11 sector cards in organized layout",
              "Each card shows sector name and symbol correctly",
              "Grid responds to window resizing (test different breakpoints)",
              "Hover effects work smoothly",
              "Loading state shows while data fetches",
              "Error handling works if getSectors() fails",
              "Cards have placeholder content for future metrics"
            ]
          }
        },
        {
          "id": "US003",
          "title": "As a user, I want a refresh button to update data",
          "description": "Add manual refresh functionality with loading states and user feedback",
          "acceptance_criteria": [
            "Refresh button in top toolbar with icon and text",
            "Button shows loading state when pressed (spinner + disabled)",
            "Data refreshes when clicked (initially mock data, real data in US007)",
            "Success/error feedback to user via toast or status message",
            "Prevents multiple simultaneous refreshes"
          ],
          "complexity": "Small", 
          "estimated_hours": 2,
          "dependencies": ["US002"],
          "status": "Not Started",
          "implementation_details": {
            "ui_design": {
              "button_location": "Top toolbar/header area, right side",
              "button_style": "Primary button with refresh icon + 'Refresh' text",
              "loading_state": "Spinner icon replaces refresh icon, button disabled and shows 'Refreshing...'",
              "feedback": "Toast notification or status bar message for success/error"
            },
            "user_control_philosophy": {
              "manual_over_automatic": "User decides when to refresh rather than automatic intervals",
              "benefits": [
                "Respects API rate limits (user won't spam refresh)",
                "Saves battery/resources",
                "User controls when they see new data",
                "No surprise data changes during analysis"
              ],
              "future_enhancement": "US015 will add optional auto-refresh for users who want it"
            },
            "component_structure": {
              "src/components/Header.tsx": {
                "description": "Top toolbar with app title and refresh button",
                "example_jsx": [
                  "const Header = () => {",
                  "  const [refreshing, setRefreshing] = useState(false);",
                  "  const [lastRefresh, setLastRefresh] = useState<Date | null>(null);",
                  "",
                  "  const handleRefresh = async () => {",
                  "    if (refreshing) return; // Prevent double-clicks",
                  "",
                  "    setRefreshing(true);",
                  "    try {",
                  "      // For now: just simulate data refresh",
                  "      await new Promise(resolve => setTimeout(resolve, 1500));",
                  "      setLastRefresh(new Date());",
                  "      showToast('Data refreshed successfully', 'success');",
                  "    } catch (error) {",
                  "      showToast('Failed to refresh data', 'error');",
                  "    } finally {",
                  "      setRefreshing(false);",
                  "    }",
                  "  };",
                  "",
                  "  return (",
                  "    <header className=\"app-header\">",
                  "      <h1 className=\"app-title\">Sector View</h1>",
                  "      <div className=\"header-actions\">",
                  "        {lastRefresh && (",
                  "          <span className=\"last-refresh\">",
                  "            Last updated: {formatTime(lastRefresh)}",
                  "          </span>",
                  "        )}",
                  "        <button",
                  "          className={`refresh-btn ${refreshing ? 'loading' : ''}`}",
                  "          onClick={handleRefresh}",
                  "          disabled={refreshing}",
                  "        >",
                  "          {refreshing ? (",
                  "            <>",
                  "              <SpinnerIcon className=\"spin\" />",
                  "              Refreshing...",
                  "            </>",
                  "          ) : (",
                  "            <>",
                  "              <RefreshIcon />",
                  "              Refresh",
                  "            </>",
                  "          )}",
                  "        </button>",
                  "      </div>",
                  "    </header>",
                  "  );",
                  "};"
                ]
              },
              "src/components/Toast.tsx": {
                "description": "Simple toast notification system for user feedback",
                "purpose": "Show success/error messages after refresh attempts"
              }
            },
            "mock_data_strategy": {
              "during_us003": "Simulate refresh by changing placeholder values or timestamps",
              "example_mock_refresh": [
                "// Simulate data change by updating timestamp or random values",
                "const mockRefresh = () => {",
                "  const mockChanges = ['+1.2%', '-0.8%', '+2.1%', '--'];",
                "  const randomChange = mockChanges[Math.floor(Math.random() * mockChanges.length)];",
                "  // Update sector cards with new mock values",
                "};"
              ],
              "visual_feedback": "Show different placeholder values, updated timestamps, or subtle animation"
            },
            "integration_with_future_stories": {
              "us007_connection": "Refresh button will call market data refresh functions",
              "refresh_context": "Pass refresh trigger down to SectorGrid component",
              "data_invalidation": "Clear cached data and fetch fresh from API"
            },
            "css_styling": {
              "src/styles/Header.css": {
                "key_styles": [
                  ".app-header {",
                  "  display: flex;",
                  "  justify-content: space-between;",
                  "  align-items: center;",
                  "  padding: 16px 24px;",
                  "  background: #ffffff;",
                  "  border-bottom: 1px solid #e2e8f0;",
                  "  box-shadow: 0 1px 3px rgba(0,0,0,0.1);",
                  "}",
                  "",
                  ".app-title {",
                  "  font-size: 24px;",
                  "  font-weight: 700;",
                  "  color: #1f2937;",
                  "  margin: 0;",
                  "}",
                  "",
                  ".header-actions {",
                  "  display: flex;",
                  "  align-items: center;",
                  "  gap: 16px;",
                  "}",
                  "",
                  ".last-refresh {",
                  "  font-size: 14px;",
                  "  color: #6b7280;",
                  "}",
                  "",
                  ".refresh-btn {",
                  "  display: flex;",
                  "  align-items: center;",
                  "  gap: 8px;",
                  "  background: #3b82f6;",
                  "  color: white;",
                  "  border: none;",
                  "  border-radius: 6px;",
                  "  padding: 10px 16px;",
                  "  font-size: 14px;",
                  "  font-weight: 500;",
                  "  cursor: pointer;",
                  "  transition: all 0.2s ease;",
                  "}",
                  "",
                  ".refresh-btn:hover:not(:disabled) {",
                  "  background: #2563eb;",
                  "  transform: translateY(-1px);",
                  "}",
                  "",
                  ".refresh-btn:disabled {",
                  "  opacity: 0.7;",
                  "  cursor: not-allowed;",
                  "  transform: none;",
                  "}",
                  "",
                  ".spin {",
                  "  animation: spin 1s linear infinite;",
                  "}",
                  "",
                  "@keyframes spin {",
                  "  from { transform: rotate(0deg); }",
                  "  to { transform: rotate(360deg); }",
                  "}"
                ]
              }
            },
            "user_experience_details": {
              "double_click_prevention": "Disable button while refreshing to prevent multiple API calls",
              "visual_feedback": "Spinner animation and text change during refresh",
              "timestamp_display": "Show 'Last updated: 2:34 PM' so users know data freshness",
              "error_handling": "Clear error messages, don't crash on failed refresh"
            },
            "accessibility": [
              "Button has proper ARIA labels",
              "Loading state announced to screen readers", 
              "Keyboard navigation support",
              "High contrast button colors"
            ],
            "validation_steps": [
              "Refresh button appears in top toolbar with proper styling",
              "Button shows loading state when clicked (spinner + disabled)",
              "Mock data changes visually after refresh completes",
              "Success message shows after successful refresh", 
              "Error message shows if refresh fails (simulate network error)",
              "Double-clicking doesn't trigger multiple refreshes",
              "Last refresh timestamp updates correctly",
              "Button returns to normal state after refresh completes"
            ]
          }
        }
      ]
    },
    "epic_2_data_layer": {
      "title": "Data Foundation",
      "priority": "P0",
      "stories": [
        {
          "id": "US004",
          "title": "As a developer, I want SQLite database setup",
          "description": "Create minimal database schema and connection handling",
          "acceptance_criteria": [
            "SQLite database file created in app data directory",
            "Basic sectors and stocks tables created",
            "Database connection established in Rust",
            "Migration system for future schema changes",
            "Error handling for database failures"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": [],
          "status": "Not Started",
          "implementation_details": {
            "minimal_schema": {
              "philosophy": "Start with just sectors and stocks tables. Add market data tables later when we implement US007 (market data integration).",
              "tables": {
                "sectors": [
                  "id INTEGER PRIMARY KEY",
                  "name TEXT NOT NULL (e.g., 'Technology')",
                  "symbol TEXT NOT NULL (e.g., 'XLK' - sector ETF symbol)"
                ],
                "stocks": [
                  "id INTEGER PRIMARY KEY", 
                  "symbol TEXT NOT NULL (e.g., 'AAPL')",
                  "name TEXT NOT NULL (e.g., 'Apple Inc.')",
                  "sector_id INTEGER NULL REFERENCES sectors(id) -- Nullable for unclassified stocks"
                ]
              }
            },
            "rust_dependencies": [
              "sqlx = { version = '0.7', features = ['sqlite', 'runtime-tokio-rustls'] }",
              "tokio = { version = '1.0', features = ['full'] }"
            ],
            "key_files": {
              "src-tauri/src/database.rs": {
                "description": "Database connection and basic operations",
                "functions": [
                  "init_database() -> Result<SqlitePool>",
                  "create_tables() -> Result<()>", 
                  "get_connection() -> &SqlitePool"
                ]
              },
              "src-tauri/migrations/001_initial.sql": {
                "description": "Initial schema creation",
                "content": "CREATE TABLE sectors...; CREATE TABLE stocks...;"
              }
            },
            "validation_steps": [
              "Database file created at correct app data location",
              "Tables created successfully with correct schema",
              "Can insert/select from both tables",
              "Can insert stocks with NULL sector_id (unclassified stocks)",
              "Connection pool handles multiple queries",
              "Graceful error handling for DB failures"
            ],
            "handling_null_sectors": {
              "ui_display": "Show unclassified stocks in separate 'Unclassified' section",
              "outlier_analysis": "Exclude NULL sector stocks from sector-based outlier detection",
              "data_loading": "Allow stock imports to succeed even without sector assignment"
            },
            "future_evolution": [
              "US007: Add market_data table for prices/volume",
              "US008: Add outlier_alerts table for detection results", 
              "US012: Add historical_data table for time series"
            ]
          }
        },
        {
          "id": "US005",
          "title": "As a developer, I want to populate initial sector data",
          "description": "Seed database with 11 GICS sectors and major S&P 500 stocks",
          "acceptance_criteria": [
            "All 11 GICS sectors inserted with ETF symbols",
            "Representative S&P 500 stocks added per sector (~50-100 total for MVP)",
            "Proper foreign key relationships established",
            "Some stocks with NULL sector_id for testing edge cases"
          ],
          "complexity": "Medium",
          "estimated_hours": 3,
          "dependencies": ["US004"],
          "status": "Not Started",
          "implementation_details": {
            "sector_seed_data": [
              { "symbol": "XLK", "name": "Information Technology" },
              { "symbol": "XLV", "name": "Health Care" },
              { "symbol": "XLF", "name": "Financials" },
              { "symbol": "XLY", "name": "Consumer Discretionary" },
              { "symbol": "XLC", "name": "Communication Services" },
              { "symbol": "XLI", "name": "Industrials" },
              { "symbol": "XLP", "name": "Consumer Staples" },
              { "symbol": "XLE", "name": "Energy" },
              { "symbol": "XLU", "name": "Utilities" },
              { "symbol": "XLRE", "name": "Real Estate" },
              { "symbol": "XLB", "name": "Materials" }
            ],
            "sample_stocks_per_sector": {
              "XLK": ["AAPL", "MSFT", "GOOGL", "NVDA", "META"],
              "XLV": ["JNJ", "PFE", "UNH", "ABBV", "TMO"],
              "XLF": ["JPM", "BAC", "WFC", "GS", "MS"],
              "XLY": ["AMZN", "TSLA", "HD", "MCD", "NKE"],
              "XLC": ["GOOGL", "META", "VZ", "T", "DIS"],
              "XLI": ["BA", "CAT", "UPS", "GE", "RTX"],
              "XLP": ["PG", "KO", "PEP", "WMT", "COST"],
              "XLE": ["XOM", "CVX", "COP", "EOG", "SLB"],
              "XLU": ["NEE", "SO", "DUK", "AEP", "EXC"],
              "XLRE": ["AMT", "PLD", "CCI", "EQIX", "SPG"],
              "XLB": ["LIN", "APD", "SHW", "FCX", "DOW"]
            },
            "seed_approach": "Start with ~5 major stocks per sector for MVP. Can expand to full S&P 500 later.",
            "key_files": {
              "src-tauri/src/seed_data.rs": {
                "description": "Hardcoded sector and stock data for initial population",
                "functions": [
                  "seed_sectors() -> Result<()>",
                  "seed_sample_stocks() -> Result<()>",
                  "seed_unclassified_examples() -> Result<()>"
                ]
              }
            },
            "validation_steps": [
              "All 11 sectors inserted with correct ETF symbols",
              "Sample stocks inserted with proper sector assignments",
              "At least 1-2 stocks with NULL sector_id for edge case testing",
              "Foreign key relationships working correctly",
              "No duplicate symbols in either table"
            ]
          }
        },
        {
          "id": "US006",
          "title": "As a developer, I want Tauri commands for data access",
          "description": "Create Rust commands that React can call for database operations",
          "acceptance_criteria": [
            "get_sectors() command returns all sectors",
            "get_stocks_by_sector(id) returns stocks for a sector", 
            "Commands handle errors gracefully",
            "TypeScript interfaces defined for return types",
            "React components can successfully call Rust functions"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US005"],
          "status": "Not Started",
          "implementation_details": {
            "tauri_concepts": {
              "what_are_commands": "Tauri commands are Rust functions that React can call like API endpoints. They're the bridge between your frontend and backend.",
              "how_it_works": [
                "1. Write Rust function with #[tauri::command] annotation",
                "2. Register command in main.rs",
                "3. Call from React using invoke() function",
                "4. Data flows: React -> Tauri -> Rust -> Database -> Rust -> Tauri -> React"
              ],
              "beginner_friendly": "Don't worry about complex Rust concepts yet - focus on the patterns and copy-paste approach"
            },
            "step_by_step": {
              "1_create_types": {
                "file": "src-tauri/src/types.rs",
                "purpose": "Define data structures shared between Rust and React",
                "code": "use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Sector {\n    pub id: i32,\n    pub name: String,\n    pub symbol: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Stock {\n    pub id: i32,\n    pub symbol: String,\n    pub name: String,\n    pub sector_id: Option<i32>,\n}"
              },
              "2_create_commands": {
                "file": "src-tauri/src/commands.rs", 
                "purpose": "Write the actual functions React can call",
                "code": "use crate::{database::get_connection, types::{Sector, Stock}};\n\n#[tauri::command]\npub async fn get_sectors() -> Result<Vec<Sector>, String> {\n    let pool = get_connection().map_err(|e| e.to_string())?;\n    \n    let rows = sqlx::query!(\"SELECT id, name, symbol FROM sectors\")\n        .fetch_all(&pool)\n        .await\n        .map_err(|e| format!(\"Database error: {}\", e))?;\n    \n    let sectors = rows.into_iter().map(|row| Sector {\n        id: row.id,\n        name: row.name,\n        symbol: row.symbol,\n    }).collect();\n    \n    Ok(sectors)\n}\n\n#[tauri::command]\npub async fn get_stocks_by_sector(sector_id: i32) -> Result<Vec<Stock>, String> {\n    let pool = get_connection().map_err(|e| e.to_string())?;\n    \n    let rows = sqlx::query!(\"SELECT id, symbol, name, sector_id FROM stocks WHERE sector_id = ?\", sector_id)\n        .fetch_all(&pool)\n        .await\n        .map_err(|e| format!(\"Database error: {}\", e))?;\n    \n    let stocks = rows.into_iter().map(|row| Stock {\n        id: row.id,\n        symbol: row.symbol,\n        name: row.name,\n        sector_id: row.sector_id,\n    }).collect();\n    \n    Ok(stocks)\n}"
              },
              "3_register_commands": {
                "file": "src-tauri/src/main.rs",
                "purpose": "Tell Tauri about your commands",
                "changes": "Add: mod commands;\nmod types;\n\nIn .invoke_handler(): commands::get_sectors, commands::get_stocks_by_sector"
              },
              "4_react_types": {
                "file": "src/types/database.ts",
                "purpose": "TypeScript interfaces matching Rust structs",
                "code": "export interface Sector {\n  id: number;\n  name: string;\n  symbol: string;\n}\n\nexport interface Stock {\n  id: number;\n  symbol: string;\n  name: string;\n  sector_id: number | null;\n}"
              },
              "5_react_hook": {
                "file": "src/hooks/useDatabase.ts", 
                "purpose": "Easy way to call Rust from React components",
                "code": "import { invoke } from '@tauri-apps/api/tauri';\nimport { Sector, Stock } from '../types/database';\n\nexport const useDatabase = () => {\n  const getSectors = async (): Promise<Sector[]> => {\n    try {\n      return await invoke<Sector[]>('get_sectors');\n    } catch (error) {\n      console.error('Failed to get sectors:', error);\n      throw error;\n    }\n  };\n\n  const getStocksBySector = async (sectorId: number): Promise<Stock[]> => {\n    try {\n      return await invoke<Stock[]>('get_stocks_by_sector', { sectorId });\n    } catch (error) {\n      console.error('Failed to get stocks:', error);\n      throw error;\n    }\n  };\n\n  return { getSectors, getStocksBySector };\n};"
              }
            },
            "rust_for_beginners": {
              "key_concepts": {
                "Result<T, E>": "Rust's way of handling success (T) or error (E)",
                "#[tauri::command]": "Annotation that makes Rust function callable from React",
                "async/await": "Non-blocking operations for database calls",
                "map_err()": "Convert different error types to String for Tauri",
                "Option<T>": "Rust's way of saying 'this might be null'"
              },
              "copy_paste_approach": "Don't worry about understanding every Rust detail - focus on the patterns and modify as needed"
            },
            "testing_strategy": [
              "1. Start with get_sectors() - no parameters, easier to test",
              "2. Test in browser console: await window.__TAURI__.invoke('get_sectors')",
              "3. Add get_stocks_by_sector() once first command works", 
              "4. Create React components that use the hooks",
              "5. Add error handling and loading states"
            ],
            "validation_steps": [
              "Can call get_sectors() from React browser console",
              "Returns array of 11 sectors with correct structure",
              "Can call get_stocks_by_sector(1) and get stocks for sector 1",
              "TypeScript types prevent errors (no red squiggles)", 
              "Error handling works (try invalid sector ID)",
              "React components can use the database hooks successfully"
            ]
          }
        }
      ]
    },
    "epic_3_market_data": {
      "title": "Real Market Data Integration", 
      "priority": "P1",
      "stories": [
        {
          "id": "US007",
          "title": "As a user, I want to see real sector performance data",
          "description": "Connect to Yahoo Finance API and display actual market data",
          "acceptance_criteria": [
            "Yahoo Finance API integration working for both price and fundamental data",
            "Sector cards show multiple metrics (price change %, avg P/E, market cap)",
            "Market data table captures comprehensive financial metrics",
            "Data updates when refresh is pressed", 
            "Handles API errors gracefully (shows cached data)",
            "Respects API rate limits (no more than 2000 requests/hour)",
            "Missing fundamental data handled without crashes"
          ],
          "complexity": "Large",
          "estimated_hours": 8,
          "dependencies": ["US006"],
          "status": "Not Started",
          "implementation_details": {
            "api_strategy": {
              "primary": "Yahoo Finance via Rust reqwest HTTP client",
              "endpoints": {
                "quotes": "https://query1.finance.yahoo.com/v8/finance/chart/{symbol}",
                "fundamentals": "https://query2.finance.yahoo.com/v10/finance/quoteSummary/{symbol}?modules=defaultKeyStatistics,summaryDetail,price"
              },
              "rate_limit": "2000 requests/hour (Yahoo's free tier)",
              "data_richness": "Fetch comprehensive metrics: price, volume, P/E, market cap, beta, 52-week range, etc.",
              "backup_plan": "If blocked, fall back to cached data or yfinance Python service"
            },
            "database_evolution": {
              "new_table": "market_data",
              "schema": [
                "id INTEGER PRIMARY KEY",
                "stock_id INTEGER NOT NULL REFERENCES stocks(id)",
                "timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP",
                "-- Price Data --",
                "price REAL NOT NULL",
                "price_change REAL NOT NULL -- Dollar change from previous close",
                "price_change_percent REAL NOT NULL -- Percentage change",
                "-- Volume & Liquidity --", 
                "volume INTEGER",
                "avg_volume_10d INTEGER -- 10-day average volume",
                "-- Market & Valuation --",
                "market_cap INTEGER",
                "pe_ratio REAL -- Price-to-Earnings ratio",
                "pb_ratio REAL -- Price-to-Book ratio",
                "-- Profitability --",
                "eps REAL -- Earnings Per Share",
                "dividend_yield REAL -- Annual dividend yield %",
                "-- Volatility --",
                "beta REAL -- Stock beta (volatility vs market)",
                "-- 52-Week Range --",
                "week52_high REAL",
                "week52_low REAL"
              ],
              "indexes": [
                "CREATE INDEX idx_market_data_stock_timestamp ON market_data(stock_id, timestamp)",
                "CREATE INDEX idx_market_data_timestamp ON market_data(timestamp)"
              ]
            },
            "data_flow": [
              "1. Fetch comprehensive stock data for all seeded stocks (~55 stocks)",
              "2. Parse both price data (chart API) and fundamentals (quoteSummary API)",
              "3. Insert/update market_data table with rich financial metrics",
              "4. Calculate sector averages across multiple dimensions:",
              "   - Price performance (%, volume-weighted)",
              "   - Valuation metrics (avg P/E, P/B ratios per sector)", 
              "   - Volatility (avg beta, price volatility)",
              "   - Market cap distribution",
              "5. Cache multi-dimensional sector data for UI and outlier detection",
              "6. Update React UI with comprehensive sector analytics"
            ],
            "caching_strategy": {
              "in_memory": "Store latest sector averages in Rust HashMap",
              "database": "Keep last 24h of market_data for offline fallback",
              "ttl": "Cache valid for 15 minutes during market hours",
              "offline_mode": "Show cached data with timestamp when API fails"
            },
            "rust_dependencies": [
              "reqwest = { version = '0.11', features = ['json'] }",
              "serde = { version = '1.0', features = ['derive'] }",
              "serde_json = '1.0'",
              "chrono = { version = '0.4', features = ['serde'] }"
            ],
            "key_files": {
              "src-tauri/src/market_data.rs": {
                "description": "Yahoo Finance API client and data fetching",
                "functions": [
                  "fetch_stock_quote(symbol: &str) -> Result<StockQuote>",
                  "fetch_all_stocks() -> Result<Vec<StockQuote>>",
                  "calculate_sector_averages(quotes: Vec<StockQuote>) -> HashMap<i32, SectorAverage>"
                ]
              },
              "src-tauri/src/cache.rs": {
                "description": "In-memory caching with TTL",
                "functions": [
                  "get_cached_sectors() -> Option<Vec<SectorSummary>>",
                  "cache_sector_data(data: Vec<SectorSummary>)",
                  "is_cache_expired() -> bool"
                ]
              },
              "src-tauri/migrations/002_market_data.sql": {
                "description": "Add market_data table and indexes",
                "content": "CREATE TABLE market_data (...); CREATE INDEX ..."
              }
            },
            "tauri_commands": [
              "#[tauri::command] async fn refresh_market_data() -> Result<Vec<SectorSummary>, String>",
              "#[tauri::command] async fn get_sector_performance() -> Result<Vec<SectorSummary>, String>"
            ],
            "error_handling": {
              "api_failure": "Return cached data with warning message",
              "rate_limit_hit": "Show 'too many requests' error, use cache",
              "network_timeout": "Fall back to last known data",
              "invalid_response": "Log error, skip problematic stocks"
            },
            "validation_steps": [
              "Can fetch comprehensive data for all seeded stocks (AAPL, MSFT, etc.)",
              "Market data table populated with prices, P/E ratios, market caps, etc.",
              "Sector cards display multiple metrics (price change, avg P/E, etc.)",
              "All fundamental data fields have reasonable values (P/E > 0, market cap > 0)",
              "Cache works - second refresh is faster than first",
              "Graceful degradation when API is unavailable",
              "No rate limit violations during normal usage",
              "Missing data handled gracefully (some stocks may lack P/E, etc.)"
            ]
          }
        },
        {
          "id": "US008",
          "title": "As a user, I want to see stock outliers in each sector",
          "description": "Implement basic outlier detection (>1.5σ from sector average)",
          "acceptance_criteria": [
            "Calculate sector averages for price change %",
            "Identify stocks >1.5 standard deviations from average",
            "Display outlier count on sector cards",
            "Color code: green for underperforming, red for outperforming"
          ],
          "complexity": "Large",
          "estimated_hours": 6,
          "dependencies": ["US007"],
          "status": "Not Started"
        },
        {
          "id": "US009",
          "title": "As a user, I want to see detailed outlier list",
          "description": "Show scrollable list of outlier stocks with details",
          "acceptance_criteria": [
            "Scrollable list below sector grid",
            "Shows stock symbol, name, price change, sector average",
            "Shows deviation score (σ)",
            "Click on outlier shows more details"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US008"],
          "status": "Not Started"
        }
      ]
    },
    "epic_4_advanced_features": {
      "title": "Advanced Analytics",
      "priority": "P1",
      "stories": [
        {
          "id": "US010",
          "title": "As a user, I want configurable outlier thresholds",
          "description": "Allow users to adjust sensitivity of outlier detection",
          "acceptance_criteria": [
            "Settings panel with threshold slider (1.0σ - 3.0σ)",
            "Outlier detection updates in real-time as threshold changes",
            "Settings persist between app sessions",
            "Visual feedback shows how many outliers at each threshold"
          ],
          "complexity": "Medium",
          "estimated_hours": 5,
          "dependencies": ["US009"],
          "status": "Not Started"
        },
        {
          "id": "US011",
          "title": "As a user, I want multiple outlier metrics",
          "description": "Detect outliers based on volume, P/E ratio, market cap, not just price",
          "acceptance_criteria": [
            "Volume outlier detection",
            "P/E ratio outlier detection", 
            "Market cap outlier detection",
            "User can select which metrics to analyze",
            "Combined outlier score across multiple metrics"
          ],
          "complexity": "Large",
          "estimated_hours": 8,
          "dependencies": ["US010"],
          "status": "Not Started"
        },
        {
          "id": "US012",
          "title": "As a user, I want historical outlier analysis",
          "description": "See how current outliers performed over past periods",
          "acceptance_criteria": [
            "Store historical market data (1 week minimum)",
            "Show outlier performance over 1d, 3d, 7d periods",
            "Highlight consistently strong/weak outliers",
            "Performance attribution vs sector average"
          ],
          "complexity": "Large",
          "estimated_hours": 10,
          "dependencies": ["US011"],
          "status": "Not Started"
        }
      ]
    },
    "epic_5_polish": {
      "title": "User Experience & Polish",
      "priority": "P2", 
      "stories": [
        {
          "id": "US013",
          "title": "As a user, I want the app to look professional",
          "description": "Improve styling, animations, and visual design",
          "acceptance_criteria": [
            "Consistent color scheme and typography",
            "Smooth animations for data updates",
            "Professional-looking sector cards with charts",
            "Dark/light theme support",
            "Loading states and progress indicators"
          ],
          "complexity": "Medium",
          "estimated_hours": 6,
          "dependencies": ["US009"],
          "status": "Not Started"
        },
        {
          "id": "US014",
          "title": "As a user, I want to export outlier data",
          "description": "Export current outliers to CSV or JSON for further analysis", 
          "acceptance_criteria": [
            "Export button in toolbar",
            "CSV format with all outlier details",
            "JSON format for programmatic use",
            "File saved to user's Downloads folder",
            "Timestamp in filename"
          ],
          "complexity": "Small",
          "estimated_hours": 3,
          "dependencies": ["US013"],
          "status": "Not Started"
        },
        {
          "id": "US015",
          "title": "As a user, I want automatic data refresh",
          "description": "App automatically refreshes during market hours",
          "acceptance_criteria": [
            "Auto-refresh every 15 minutes during market hours (9:30am-4pm ET)",
            "Pause auto-refresh outside market hours",
            "User can disable/configure auto-refresh",
            "Visual indicator shows time until next refresh",
            "Respect API rate limits"
          ],
          "complexity": "Medium",
          "estimated_hours": 4,
          "dependencies": ["US013"],
          "status": "Not Started"
        }
      ]
    }
  },
  "technical_tasks": {
    "infrastructure": [
      {
        "id": "TECH001",
        "title": "Setup Tauri project structure",
        "description": "Initialize Tauri app with React frontend",
        "priority": "P0",
        "complexity": "Small",
        "estimated_hours": 1,
        "dependencies": [],
        "related_stories": ["US001"],
        "status": "Not Started"
      },
      {
        "id": "TECH002", 
        "title": "Configure TypeScript and build tools",
        "description": "Setup TS, linting, formatting, build pipeline",
        "priority": "P0",
        "complexity": "Small",
        "estimated_hours": 2,
        "dependencies": ["TECH001"],
        "related_stories": ["US001"],
        "status": "Not Started"
      },
      {
        "id": "TECH003",
        "title": "Setup SQLite with migrations",
        "description": "Database initialization and schema management",
        "priority": "P0", 
        "complexity": "Medium",
        "estimated_hours": 3,
        "dependencies": ["TECH001"],
        "related_stories": ["US004"],
        "status": "Not Started"
      }
    ],
    "data_integration": [
      {
        "id": "TECH004",
        "title": "Yahoo Finance API client",
        "description": "Rust HTTP client for fetching market data",
        "priority": "P1",
        "complexity": "Large",
        "estimated_hours": 5,
        "dependencies": ["TECH003"],
        "related_stories": ["US007"],
        "status": "Not Started"
      },
      {
        "id": "TECH005",
        "title": "Statistical analysis module",
        "description": "Outlier detection algorithms in Rust",
        "priority": "P1",
        "complexity": "Large", 
        "estimated_hours": 6,
        "dependencies": ["TECH004"],
        "related_stories": ["US008", "US011"],
        "status": "Not Started"
      },
      {
        "id": "TECH006",
        "title": "Data caching and persistence",
        "description": "Efficient data storage and retrieval strategies",
        "priority": "P1",
        "complexity": "Medium",
        "estimated_hours": 4,
        "dependencies": ["TECH004"],
        "related_stories": ["US012"],
        "status": "Not Started"
      }
    ]
  },
  "milestones": [
    {
      "name": "MVP Demo",
      "target_date": "2025-02-15",
      "description": "Basic app with sector grid and mock data",
      "required_stories": ["US001", "US002", "US003"],
      "status": "Planned"
    },
    {
      "name": "Alpha Release",
      "target_date": "2025-03-01", 
      "description": "Working outlier detection with real data",
      "required_stories": ["US004", "US005", "US006", "US007", "US008", "US009"],
      "status": "Planned"
    },
    {
      "name": "Beta Release",
      "target_date": "2025-03-15",
      "description": "Advanced features and polish",
      "required_stories": ["US010", "US011", "US013", "US014"],
      "status": "Planned"
    },
    {
      "name": "Portfolio Ready",
      "target_date": "2025-03-30",
      "description": "Production-ready app for job applications",
      "required_stories": ["US012", "US015"],
      "status": "Planned"
    }
  ],
  "success_metrics": [
    {
      "metric": "App Launch Time",
      "target": "< 2 seconds",
      "current": "N/A"
    },
    {
      "metric": "Data Refresh Speed", 
      "target": "< 10 seconds",
      "current": "N/A"
    },
    {
      "metric": "Memory Usage",
      "target": "< 100MB",
      "current": "N/A"
    },
    {
      "metric": "Bundle Size",
      "target": "< 15MB", 
      "current": "N/A"
    }
  ],
  "risks": [
    {
      "risk": "API Rate Limits",
      "impact": "High",
      "probability": "Medium",
      "mitigation": "Implement caching, use multiple data sources, respect rate limits"
    },
    {
      "risk": "Market Data Quality",
      "impact": "Medium", 
      "probability": "Low",
      "mitigation": "Data validation, multiple sources, graceful degradation"
    },
    {
      "risk": "Cross-platform Compatibility",
      "impact": "Low",
      "probability": "Low", 
      "mitigation": "Focus on macOS first, Tauri handles most cross-platform issues"
    }
  ],
  "notes": {
    "last_updated": "2025-01-23",
    "next_review": "2025-01-30",
    "team_size": "1 developer + AI assistants",
    "budget": "Free tier APIs, $0 budget constraint"
  }
}